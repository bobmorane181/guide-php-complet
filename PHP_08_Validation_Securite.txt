================================================================================
              PHP MODULE 8 : VALIDATION ET SÉCURITÉ DES FORMULAIRES
================================================================================

TABLE DES MATIÈRES
==================
1. Sécurité et Validation - Introduction
2. Les Expressions Régulières (Regex) - Guide Complet ⭐ NOUVELLE SECTION
   A. Littéraux
   B. Alternation (|)
   C. Ensembles de caractères []
   D. Wildcard (.)
   E. Ranges [a-z]
   F. Classes raccourcies (\w, \d, \s)
   G. Groupements ()
   H. Quantificateurs fixes {}
   I. Optionnel (?)
   J. Kleene star (*)
   K. Kleene plus (+)
   L. Ancres (^ et $)
   M. Récapitulatif des symboles
   N. Exemples pratiques
   O. Utilisation en PHP
   P. Utilisation en HTML
   Q. Bonnes pratiques
   R. Exercices pratiques
   S. Résumé
3. Validation HTML5 Intégrée
4. Validation JavaScript Personnalisée
5. Validation Asynchrone (AJAX)
6. Validation Back-End (Serveur) - OBLIGATOIRE
7. Stratégie de Validation Complète
8. Récapitulatif - Validation de Formulaires


================================================================================
H. SÉCURITÉ ET VALIDATION
================================================================================

⚠️ TRÈS IMPORTANT: TOUJOURS valider et nettoyer les données utilisateur!

Les données de $_GET, $_POST, $_REQUEST proviennent de l'utilisateur et
peuvent être DANGEREUSES (injection SQL, XSS, etc.).

EXEMPLE - Validation basique:

    <?php
    // ✗ DANGER - Jamais faire ça:
    echo $_POST["nom"];

    // ✓ MIEUX - Nettoyer les données:
    $nom = htmlspecialchars($_POST["nom"]);
    echo $nom;

    // ✓ ENCORE MIEUX - Vérifier l'existence:
    if (isset($_POST["nom"]) && !empty($_POST["nom"])) {
        $nom = htmlspecialchars($_POST["nom"]);
        echo $nom;
    } else {
        echo "Nom manquant!";
    }
    ?>

FONCTIONS DE SÉCURITÉ IMPORTANTES:
- htmlspecialchars() : Échappe les caractères HTML (prévient XSS)
- isset()            : Vérifie si la variable existe
- empty()            : Vérifie si la variable est vide
- filter_input()     : Filtre et valide les données entrantes


================================================================================
H-bis. VALIDATION DE FORMULAIRES - RÉCAPITULATIF COMPLET
================================================================================

INTRODUCTION:
La validation de formulaires est ESSENTIELLE pour la sécurité et le bon
fonctionnement des sites web. Les sites modernes collectent beaucoup
d'informations via les formulaires HTML et doivent s'assurer que ces
données sont valides et sécurisées.

1. POURQUOI VALIDER LES FORMULAIRES ?
--------------------------------------

Les sites web modernes nécessitent beaucoup d'informations de leurs
utilisateurs et collectent ces données principalement via des formulaires HTML.

RAISONS ESSENTIELLES:
✓ SÉCURITÉ: Protéger contre les attaques (injection SQL, XSS, etc.)
✓ INTÉGRITÉ: Garantir que les données sont dans le bon format
✓ FONCTIONNEMENT: Assurer que l'application fonctionne correctement
✓ EXPÉRIENCE: Guider l'utilisateur en cas d'erreur de saisie

⚠️ RÈGLE D'OR: Toujours valider côté client ET côté serveur!


================================================================================
2. LES EXPRESSIONS RÉGULIÈRES (REGEX) - GUIDE COMPLET
================================================================================

DÉFINITION:
Les expressions régulières (regex) sont des SÉQUENCES SPÉCIALES DE CARACTÈRES
qui décrivent un MOTIF (pattern) de texte à faire correspondre. Elles sont
un outil puissant et essentiel pour valider les données saisies.

PUISSANCE DES REGEX:
✓ Rechercher des motifs complexes dans du texte
✓ Valider le format de données (email, téléphone, code postal)
✓ Extraire des informations spécifiques
✓ Remplacer du texte selon des motifs
✓ Vérifier la conformité de saisies utilisateur


A) LES LITTÉRAUX - CORRESPONDANCE EXACTE
-----------------------------------------

Les littéraux permettent de chercher exactement les caractères désirés.

EXEMPLE:
    Regex: abc
    Correspond à: "abc" dans "abcdef"
    Ne correspond PAS à: "ABC" (sensible à la casse)

UTILISATION EN PHP:
    if (preg_match('/abc/', $texte)) {
        echo "Trouvé!";
    }


B) L'ALTERNATION - OPÉRATEUR PIPE (|)
--------------------------------------

Le symbole pipe | permet de faire correspondre le texte AVANT OU APRÈS le |.

SYNTAXE:
    motif1|motif2

EXEMPLE:
    Regex: chat|chien
    Correspond à: "chat" OU "chien"

    Texte: "J'ai un chat"     → ✓ Match
    Texte: "J'ai un chien"    → ✓ Match
    Texte: "J'ai un oiseau"   → ✗ Pas de match

EXEMPLE PHP:
    if (preg_match('/oui|yes/', $reponse)) {
        echo "Réponse positive!";
    }


C) LES ENSEMBLES DE CARACTÈRES [...]
-------------------------------------

Les crochets [] permettent de faire correspondre UN SEUL caractère parmi
une série de caractères.

SYNTAXE:
    [abc]    → Correspond à 'a' OU 'b' OU 'c'
    [aeiou]  → Correspond à une voyelle
    [0-9]    → Correspond à un chiffre (voir ranges)

EXEMPLES:
    Regex: gr[aeiou]s
    Correspond à: "gras", "gris", "gros"
    Ne correspond PAS à: "grys" (y n'est pas dans l'ensemble)

    Regex: [Bb]onjour
    Correspond à: "Bonjour" OU "bonjour"

NÉGATION AVEC ^:
    [^abc]   → Correspond à tout SAUF 'a', 'b' ou 'c'
    [^0-9]   → Correspond à tout SAUF les chiffres

EXEMPLE PHP:
    // Vérifier qu'un texte contient une voyelle
    if (preg_match('/[aeiou]/', $texte)) {
        echo "Contient une voyelle";
    }


D) LE WILDCARD - POINT (.)
---------------------------

Le point . correspond à N'IMPORTE QUEL CARACTÈRE unique (lettre, chiffre,
symbole ou espace).

SYNTAXE:
    .    → N'importe quel caractère (sauf nouvelle ligne par défaut)

EXEMPLES:
    Regex: c.t
    Correspond à: "cat", "cot", "c9t", "c@t", "c t"

    Regex: a.c
    Correspond à: "abc", "a1c", "a c"

⚠️ ATTENTION: Pour chercher un point littéral, il faut l'échapper: \.

EXEMPLE:
    Regex: 192\.168\.1\.1
    Correspond à: "192.168.1.1" (adresse IP)

EXEMPLE PHP:
    // Valider format xxx.xxx.xxx.xxx
    if (preg_match('/\d+\.\d+\.\d+\.\d+/', $ip)) {
        echo "Format IP valide";
    }


E) LES RANGES (PLAGES) - [a-z]
-------------------------------

Les ranges permettent de spécifier une PLAGE de caractères dans laquelle
on peut faire une correspondance.

SYNTAXES COURANTES:
    [a-z]    → Lettres minuscules de a à z
    [A-Z]    → Lettres majuscules de A à Z
    [0-9]    → Chiffres de 0 à 9
    [a-zA-Z] → Toutes les lettres (min et maj)
    [0-9a-f] → Chiffres hexadécimaux

EXEMPLES:
    Regex: [0-9]
    Correspond à: "0", "1", "2", ..., "9"

    Regex: [a-z]{3}
    Correspond à: Exactement 3 lettres minuscules ("abc", "xyz")

    Regex: [A-Z][a-z]+
    Correspond à: Majuscule suivie d'une ou plusieurs minuscules ("Bonjour")

EXEMPLE PHP:
    // Vérifier code postal (5 chiffres)
    if (preg_match('/^[0-9]{5}$/', $code_postal)) {
        echo "Code postal valide";
    }


F) CLASSES DE CARACTÈRES RACCOURCIES
-------------------------------------

Des raccourcis existent pour représenter des ensembles communs.

\w  → WORD CHARACTER (caractère de mot)
      Équivaut à: [a-zA-Z0-9_]
      Correspond à: lettres, chiffres, underscore

\d  → DIGIT CHARACTER (chiffre)
      Équivaut à: [0-9]
      Correspond à: chiffres de 0 à 9

\s  → WHITESPACE CHARACTER (espace blanc)
      Correspond à: espace, tabulation, nouvelle ligne

\W  → NON-WORD (inverse de \w)
      Correspond à: tout SAUF lettres, chiffres, underscore

\D  → NON-DIGIT (inverse de \d)
      Correspond à: tout SAUF les chiffres

\S  → NON-WHITESPACE (inverse de \s)
      Correspond à: tout SAUF les espaces blancs

EXEMPLES:
    Regex: \d{3}
    Correspond à: Exactement 3 chiffres ("123", "456")

    Regex: \w+
    Correspond à: Un ou plusieurs caractères de mot ("hello", "test123")

    Regex: \s+
    Correspond à: Un ou plusieurs espaces blancs

EXEMPLE PHP:
    // Valider username (lettres, chiffres, underscore uniquement)
    if (preg_match('/^\w+$/', $username)) {
        echo "Username valide";
    }


G) LES GROUPEMENTS - PARENTHÈSES ()
------------------------------------

Les parenthèses () permettent de GROUPER des parties d'une expression
régulière et de limiter l'alternation à une partie seulement.

SYNTAXE:
    (motif)

EXEMPLES:
    Regex: (chat|chien)s
    Correspond à: "chats" OU "chiens"

    Sans groupement: chat|chiens
    Correspondrait à: "chat" OU "chiens" (pas "chats"!)

    Regex: (ha)+
    Correspond à: "ha", "haha", "hahaha", etc.

CAPTURE DE GROUPES:
Les groupements capturent aussi le texte correspondant pour extraction.

EXEMPLE PHP:
    // Extraire jour, mois, année d'une date
    if (preg_match('/(\d{2})\/(\d{2})\/(\d{4})/', $date, $matches)) {
        $jour = $matches[1];
        $mois = $matches[2];
        $annee = $matches[3];
    }


H) QUANTIFICATEURS FIXES - ACCOLADES {}
----------------------------------------

Les accolades {} permettent d'indiquer la QUANTITÉ EXACTE ou une PLAGE
de quantité d'un caractère qu'on souhaite faire correspondre.

SYNTAXES:
    {n}      → Exactement n occurrences
    {n,m}    → Entre n et m occurrences (inclus)
    {n,}     → n occurrences ou plus
    {,m}     → Jusqu'à m occurrences

EXEMPLES:
    Regex: \d{3}
    Correspond à: Exactement 3 chiffres ("123", "456")

    Regex: \d{2,4}
    Correspond à: Entre 2 et 4 chiffres ("12", "123", "1234")

    Regex: [a-z]{5,}
    Correspond à: 5 lettres minuscules ou plus

    Regex: ha{3}
    Correspond à: "haaa" (h suivi de 3 'a')

EXEMPLE PHP:
    // Valider mot de passe (minimum 8 caractères)
    if (preg_match('/^.{8,}$/', $password)) {
        echo "Longueur suffisante";
    }


I) QUANTIFICATEUR OPTIONNEL - POINT D'INTERROGATION ?
------------------------------------------------------

Le point d'interrogation ? indique qu'un caractère est OPTIONNEL
(peut apparaître 0 ou 1 fois).

SYNTAXE:
    caractère?

EXEMPLES:
    Regex: colou?r
    Correspond à: "color" OU "colour" (u est optionnel)

    Regex: https?://
    Correspond à: "http://" OU "https://" (s est optionnel)

    Regex: \d{1,3}\.?\d{3}
    Correspond à: "1000" OU "1.000" (point optionnel)

EXEMPLE PHP:
    // Email avec ou sans point avant @
    if (preg_match('/^\w+\.?\w+@/', $email)) {
        echo "Format email accepté";
    }


J) ÉTOILE DE KLEENE - ASTÉRISQUE *
-----------------------------------

L'astérisque * est un quantificateur qui fait correspondre le caractère
précédent 0 FOIS OU PLUS.

SYNTAXE:
    caractère*

EXEMPLES:
    Regex: ha*
    Correspond à: "h", "ha", "haa", "haaa", etc.

    Regex: \d*
    Correspond à: "", "1", "12", "123", etc. (même chaîne vide!)

    Regex: bon*jour
    Correspond à: "bojour", "bonjour", "bonnjour", "bonnnjour"

UTILISATION COURANTE:
    Regex: \s*
    Correspond à: Zéro ou plusieurs espaces (souvent utilisé pour ignorer les espaces)

EXEMPLE PHP:
    // Texte avec zéro ou plusieurs espaces autour
    if (preg_match('/^\s*\w+\s*$/', $texte)) {
        echo "Un mot avec espaces optionnels";
    }


K) PLUS DE KLEENE - SIGNE PLUS +
---------------------------------

Le signe + fait correspondre le caractère précédent 1 FOIS OU PLUS.

SYNTAXE:
    caractère+

EXEMPLES:
    Regex: ha+
    Correspond à: "ha", "haa", "haaa" (mais PAS "h")

    Regex: \d+
    Correspond à: "1", "12", "123" (un ou plusieurs chiffres)

    Regex: \s+
    Correspond à: Un ou plusieurs espaces

DIFFÉRENCE AVEC * :
    *  → 0 ou plus (accepte chaîne vide)
    +  → 1 ou plus (nécessite au moins 1 occurrence)

EXEMPLE PHP:
    // Au moins un chiffre requis
    if (preg_match('/\d+/', $texte)) {
        echo "Contient au moins un chiffre";
    }


L) ANCRES - CHAPEAU ^ ET DOLLAR $
----------------------------------

Les symboles d'ancrage ^ et $ sont utilisés pour faire correspondre du texte
au DÉBUT et à la FIN d'une chaîne, respectivement.

^  → DÉBUT de chaîne
$  → FIN de chaîne

EXEMPLES:
    Regex: ^Bonjour
    Correspond à: "Bonjour le monde" (commence par Bonjour)
    Ne correspond PAS à: "Dire Bonjour" (Bonjour n'est pas au début)

    Regex: fin$
    Correspond à: "C'est la fin" (finit par fin)
    Ne correspond PAS à: "fin du monde" (fin n'est pas à la fin)

    Regex: ^Hello$
    Correspond UNIQUEMENT à: "Hello" (exactement "Hello", rien d'autre)

UTILISATION COURANTE:
    ^  et  $  ensemble forcent une correspondance EXACTE de toute la chaîne.

EXEMPLE PHP:
    // Email doit être exactement un email, rien avant/après
    if (preg_match('/^[\w.-]+@[\w.-]+\.[a-z]{2,}$/i', $email)) {
        echo "Email valide";
    }


M) RÉCAPITULATIF DES SYMBOLES REGEX
------------------------------------

SYMBOLE    NOM                    FONCTION
-------    ---                    --------
.          Wildcard               N'importe quel caractère
|          Pipe (alternation)     OU logique
[]         Character set          Un caractère parmi l'ensemble
[^]        Negated set            Tout sauf l'ensemble
-          Range                  Plage de caractères
()         Grouping               Grouper des motifs
\          Escape                 Échapper un caractère spécial

\w         Word character         [a-zA-Z0-9_]
\d         Digit                  [0-9]
\s         Whitespace             Espace, tab, newline

\W         Non-word               Inverse de \w
\D         Non-digit              Inverse de \d
\S         Non-whitespace         Inverse de \s

?          Optional               0 ou 1 occurrence
*          Kleene star            0 ou plus occurrences
+          Kleene plus            1 ou plus occurrences
{n}        Fixed quantifier       Exactement n occurrences
{n,m}      Range quantifier       Entre n et m occurrences

^          Anchor start           Début de chaîne
$          Anchor end             Fin de chaîne


N) EXEMPLES PRATIQUES DE REGEX
-------------------------------

1. EMAIL:
    /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/

2. NUMÉRO DE TÉLÉPHONE (10 chiffres):
    /^0[1-9]\d{8}$/

3. CODE POSTAL FRANÇAIS:
    /^[0-9]{5}$/

4. MOT DE PASSE FORT (min 8 caractères, lettres + chiffres):
    /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/

5. URL:
    /^https?:\/\/[\w.-]+\.[a-z]{2,}(\/.*)?$/i

6. DATE (JJ/MM/AAAA):
    /^(0[1-9]|[12][0-9]|3[01])\/(0[1-9]|1[012])\/\d{4}$/

7. NOM D'UTILISATEUR (3-20 caractères alphanumériques):
    /^\w{3,20}$/

8. CARTE DE CRÉDIT (format xxxx-xxxx-xxxx-xxxx):
    /^\d{4}-\d{4}-\d{4}-\d{4}$/


O) UTILISATION EN PHP
---------------------

FONCTION preg_match():
Vérifie si un motif correspond.

    if (preg_match('/regex/', $texte)) {
        echo "Correspondance trouvée!";
    }

FONCTION preg_match_all():
Trouve toutes les correspondances.

    preg_match_all('/\d+/', $texte, $matches);
    print_r($matches);

FONCTION preg_replace():
Remplace le texte correspondant.

    $nouveau = preg_replace('/\s+/', ' ', $texte);  // Remplace multiples espaces par un seul

FONCTION preg_split():
Divise une chaîne selon un motif.

    $parts = preg_split('/[,;]/', $texte);  // Split sur virgule ou point-virgule


P) UTILISATION EN HTML (ATTRIBUT PATTERN)
------------------------------------------

L'attribut pattern utilise des regex pour la validation côté client:

    <input type="text" name="telephone"
           pattern="0[1-9][0-9]{8}"
           title="Format: 0612345678"
           required />

⚠️ NOTE: En HTML, ne pas mettre les délimiteurs / /


Q) BONNES PRATIQUES REGEX
--------------------------

✓ Commencer simple, puis complexifier progressivement
✓ Tester vos regex sur des outils en ligne (regex101.com, regexr.com)
✓ Utiliser des commentaires pour expliquer les regex complexes
✓ Échapper les caractères spéciaux avec \ quand nécessaire
✓ Utiliser des groupements () pour clarifier la logique
✓ Préférer les quantificateurs précis {n,m} aux * et + quand possible
✓ Toujours valider côté serveur en plus du client


R) EXERCICES PRATIQUES
-----------------------

Créez des regex pour valider:

1. Un prénom (lettres uniquement, 2-30 caractères)
   Réponse: /^[A-Za-zÀ-ÿ]{2,30}$/

2. Un âge (1-3 chiffres, entre 1 et 150)
   Réponse: /^(1[0-4][0-9]|150|[1-9][0-9]?)$/

3. Une couleur hexadécimale (#RGB ou #RRGGBB)
   Réponse: /^#([0-9A-Fa-f]{3}|[0-9A-Fa-f]{6})$/

4. Un identifiant Twitter (@username)
   Réponse: /^@\w{1,15}$/


S) RÉSUMÉ - EXPRESSIONS RÉGULIÈRES
-----------------------------------

Les expressions régulières sont des séquences spéciales de caractères qui
décrivent un motif de texte à faire correspondre.

✓ LITTÉRAUX: Correspondance exacte des caractères
✓ ALTERNATION (|): Permet de matcher texte avant OU après le pipe
✓ CHARACTER SETS []: Matcher un caractère parmi une série
✓ WILDCARDS (.): Matcher n'importe quel caractère unique
✓ RANGES: Spécifier une plage de caractères ([a-z], [0-9])
✓ SHORTHAND CLASSES: \w, \d, \s représentent word, digit, whitespace
✓ GROUPINGS (): Grouper des parties de regex et limiter l'alternation
✓ QUANTIFIERS {}: Indiquer quantité exacte ou plage ({3}, {2,5})
✓ OPTIONAL (?): Indiquer qu'un caractère est optionnel (0 ou 1 fois)
✓ KLEENE STAR (*): Matcher 0 ou plus occurrences
✓ KLEENE PLUS (+): Matcher 1 ou plus occurrences
✓ ANCHORS (^ et $): Matcher au début et fin de chaîne

⚠️ Les regex sont PUISSANTES mais peuvent être complexes.
   Commencez simple et testez toujours vos expressions!


================================================================================
3. VALIDATION HTML5 INTÉGRÉE
================================================================================

HTML5 offre des méthodes INTÉGRÉES très utiles pour la validation côté client.

A) ATTRIBUTS DE VALIDATION HTML5:

required - Champ obligatoire:
    <input type="text" name="nom" required />

minlength / maxlength - Longueur du texte:
    <input type="text" name="username"
           minlength="3" maxlength="20" />

min / max - Valeurs numériques:
    <input type="number" name="age"
           min="18" max="99" />

pattern - Expression régulière:
    <input type="text" name="code_postal"
           pattern="[0-9]{5}"
           title="Code postal à 5 chiffres" />

B) TYPES INPUT AVEC VALIDATION AUTOMATIQUE:

type="email" - Valide le format email:
    <input type="email" name="email" required />
    <!-- Refuse: "test" ou "test@" -->
    <!-- Accepte: "test@example.com" -->

type="url" - Valide le format URL:
    <input type="url" name="site" />
    <!-- Accepte: "https://example.com" -->

type="tel" - Pour téléphone (pas de validation auto):
    <input type="tel" name="tel" pattern="[0-9]{10}" />

type="number" - Seulement des nombres:
    <input type="number" name="quantite" min="1" />

C) MESSAGES D'ERREUR PERSONNALISÉS:

Utiliser l'attribut "title" pour guider l'utilisateur:
    <input type="text" name="cp"
           pattern="[0-9]{5}"
           title="Le code postal doit contenir exactement 5 chiffres"
           required />

AVANTAGES DE LA VALIDATION HTML5:
✓ Aucun JavaScript nécessaire
✓ Messages d'erreur automatiques
✓ Empêche la soumission si invalide
✓ Retour instantané à l'utilisateur

LIMITATIONS:
✗ Peut être contournée (désactivation JavaScript, modification HTML)
✗ Messages parfois pas assez clairs
✗ NE REMPLACE PAS la validation serveur!


================================================================================
4. VALIDATION JAVASCRIPT PERSONNALISÉE
================================================================================

Pour des validations plus COMPLEXES ou PERSONNALISÉES, JavaScript est nécessaire.

A) VALIDATION EN TEMPS RÉEL:

Valider pendant la saisie:
    <input type="text" id="username" name="username" />

    <script>
    const usernameInput = document.getElementById('username');

    usernameInput.addEventListener('input', function() {
        if (this.value.length < 3) {
            this.setCustomValidity('Minimum 3 caractères requis');
        } else {
            this.setCustomValidity('');  // Valide
        }
    });
    </script>

B) VALIDATION AVANT SOUMISSION:

Vérifier avant d'envoyer:
    <form id="monForm" onsubmit="return validerFormulaire()">
        <input type="password" id="mdp" name="mdp" />
        <input type="password" id="mdp2" name="mdp2" />
        <button type="submit">S'inscrire</button>
    </form>

    <script>
    function validerFormulaire() {
        const mdp1 = document.getElementById('mdp').value;
        const mdp2 = document.getElementById('mdp2').value;

        if (mdp1 !== mdp2) {
            alert('Les mots de passe ne correspondent pas!');
            return false;  // Empêche la soumission
        }

        return true;  // Autorise la soumission
    }
    </script>

C) VALIDATION COMPLEXE:

Vérifier la force d'un mot de passe:
    <input type="password" id="password" />
    <p id="force"></p>

    <script>
    const passwordInput = document.getElementById('password');
    const forceText = document.getElementById('force');

    passwordInput.addEventListener('input', function() {
        const mdp = this.value;
        let force = 0;

        // Critères de force
        if (mdp.length >= 8) force++;
        if (/[a-z]/.test(mdp)) force++;      // Minuscules
        if (/[A-Z]/.test(mdp)) force++;      // Majuscules
        if (/[0-9]/.test(mdp)) force++;      // Chiffres
        if (/[^A-Za-z0-9]/.test(mdp)) force++; // Caractères spéciaux

        // Affichage
        if (force < 2) forceText.textContent = 'Faible';
        else if (force < 4) forceText.textContent = 'Moyen';
        else forceText.textContent = 'Fort';
    });
    </script>

AVANTAGES JAVASCRIPT:
✓ Validation personnalisée complexe
✓ Retour visuel immédiat
✓ Meilleure expérience utilisateur
✓ Peut vérifier plusieurs champs ensemble

LIMITATIONS:
✗ Peut être désactivé par l'utilisateur
✗ Ne garantit PAS la sécurité
✗ Doit être doublée par validation serveur


================================================================================
5. VALIDATION ASYNCHRONE (AJAX)
================================================================================

Les requêtes ASYNCHRONES au serveur permettent de valider des données
AVANT la soumission du formulaire, sans recharger la page.

USAGE TYPIQUE:
- Vérifier si un nom d'utilisateur est déjà pris
- Valider un code promo en temps réel
- Vérifier si un email existe dans la base de données

EXEMPLE - Vérifier disponibilité d'un username:

HTML:
    <input type="text" id="username" name="username" />
    <span id="message"></span>

JAVASCRIPT (avec Fetch API):
    <script>
    const usernameInput = document.getElementById('username');
    const messageSpan = document.getElementById('message');

    usernameInput.addEventListener('blur', function() {
        const username = this.value;

        // Requête asynchrone au serveur
        fetch('verifier_username.php?username=' + username)
            .then(response => response.json())
            .then(data => {
                if (data.disponible) {
                    messageSpan.textContent = '✓ Disponible';
                    messageSpan.style.color = 'green';
                } else {
                    messageSpan.textContent = '✗ Déjà pris';
                    messageSpan.style.color = 'red';
                }
            });
    });
    </script>

FICHIER PHP: verifier_username.php
    <?php
    $username = $_GET['username'];

    // Vérifier dans la base de données (exemple simplifié)
    $usernames_pris = ['admin', 'test', 'user'];
    $disponible = !in_array($username, $usernames_pris);

    // Retourner JSON
    header('Content-Type: application/json');
    echo json_encode(['disponible' => $disponible]);
    ?>

AVANTAGES:
✓ Validation en temps réel sans recharger la page
✓ Utilise les données du serveur (base de données)
✓ Meilleure expérience utilisateur
✓ Détecte les problèmes avant soumission

LIMITATIONS:
✗ Requiert JavaScript activé
✗ Nécessite une connexion internet
✗ Ne remplace PAS la validation finale


================================================================================
6. VALIDATION BACK-END (SERVEUR) - OBLIGATOIRE
================================================================================

⚠️ CRUCIAL: Une validation finale BACK-END de TOUTES les données est
OBLIGATOIRE pour garantir la sécurité de l'application!

POURQUOI C'EST ESSENTIEL:

1. La validation client peut être CONTOURNÉE:
   - JavaScript peut être désactivé
   - L'HTML peut être modifié (DevTools)
   - Des requêtes peuvent être envoyées directement (curl, Postman)

2. La validation serveur est LA SEULE GARANTIE de sécurité

EXEMPLE COMPLET - Validation PHP côté serveur:

    <?php
    // Réception des données
    if ($_SERVER["REQUEST_METHOD"] === "POST") {

        $erreurs = [];

        // 1. VALIDATION - Nom (requis, 2-50 caractères)
        if (empty($_POST["nom"])) {
            $erreurs[] = "Le nom est requis";
        } elseif (strlen($_POST["nom"]) < 2 || strlen($_POST["nom"]) > 50) {
            $erreurs[] = "Le nom doit contenir entre 2 et 50 caractères";
        }

        // 2. VALIDATION - Email (requis, format valide)
        if (empty($_POST["email"])) {
            $erreurs[] = "L'email est requis";
        } elseif (!filter_var($_POST["email"], FILTER_VALIDATE_EMAIL)) {
            $erreurs[] = "Format d'email invalide";
        }

        // 3. VALIDATION - Âge (requis, entre 18 et 99)
        if (empty($_POST["age"])) {
            $erreurs[] = "L'âge est requis";
        } elseif (!is_numeric($_POST["age"])) {
            $erreurs[] = "L'âge doit être un nombre";
        } elseif ($_POST["age"] < 18 || $_POST["age"] > 99) {
            $erreurs[] = "L'âge doit être entre 18 et 99";
        }

        // 4. SANITIZATION - Nettoyer les données
        $nom = htmlspecialchars(trim($_POST["nom"]));
        $email = filter_var($_POST["email"], FILTER_SANITIZE_EMAIL);
        $age = intval($_POST["age"]);

        // 5. TRAITEMENT - Si pas d'erreurs
        if (empty($erreurs)) {
            // Données valides et nettoyées
            // Insérer en base de données, envoyer email, etc.
            echo "Inscription réussie!";
        } else {
            // Afficher les erreurs
            foreach ($erreurs as $erreur) {
                echo "<p style='color:red;'>$erreur</p>";
            }
        }
    }
    ?>

FONCTIONS PHP IMPORTANTES:

VALIDATION:
- empty()                : Vérifie si vide
- is_numeric()           : Vérifie si nombre
- filter_var()           : Valide email, URL, etc.
- preg_match()           : Vérifie regex
- strlen()               : Longueur de chaîne

SANITIZATION (NETTOYAGE):
- htmlspecialchars()     : Échappe HTML (prévient XSS)
- trim()                 : Retire espaces début/fin
- strip_tags()           : Retire balises HTML
- filter_var()           : Nettoie email, URL, etc.
- intval()               : Convertit en entier
- floatval()             : Convertit en décimal


================================================================================
7. STRATÉGIE DE VALIDATION COMPLÈTE
================================================================================

Pour une sécurité optimale, utilisez PLUSIEURS NIVEAUX de validation:

NIVEAU 1 - VALIDATION HTML5 (Côté client):
✓ Validation de base instantanée
✓ Attributs: required, pattern, min, max, etc.
✓ Types: email, url, number, etc.
→ Améliore l'expérience utilisateur

NIVEAU 2 - VALIDATION JAVASCRIPT (Côté client):
✓ Validations personnalisées complexes
✓ Retour visuel en temps réel
✓ Vérification de cohérence entre champs
→ Guide l'utilisateur avant soumission

NIVEAU 3 - VALIDATION ASYNCHRONE (Client → Serveur):
✓ Vérifications nécessitant les données serveur
✓ Disponibilité username, code promo, etc.
✓ Avant la soumission finale
→ Détecte les problèmes tôt

NIVEAU 4 - VALIDATION BACK-END (Serveur) ⚠️ OBLIGATOIRE:
✓ Validation COMPLÈTE de toutes les données
✓ Sanitization (nettoyage) de toutes les données
✓ Seule vraie garantie de sécurité
→ Protection finale et indispensable

FLUX COMPLET:
    1. Utilisateur saisit → HTML5 valide instantanément
    2. Utilisateur continue → JavaScript valide en temps réel
    3. Avant soumission → AJAX vérifie avec serveur si nécessaire
    4. Soumission → PHP valide et nettoie TOUT côté serveur
    5. Traitement → Données sûres et valides


================================================================================
8. RÉCAPITULATIF - VALIDATION DE FORMULAIRES
================================================================================

POINTS CLÉS À RETENIR:

1. Les sites web modernes collectent beaucoup d'informations via
   des formulaires HTML

2. Il est ESSENTIEL de valider les données soumises pour:
   - Maintenir la sécurité des sites
   - Garantir le bon fonctionnement

3. Les EXPRESSIONS RÉGULIÈRES (regex) sont des séquences de caractères
   qui définissent des motifs à rechercher dans du texte
   - Outil important pour valider les données saisies

4. HTML5 moderne offre des méthodes INTÉGRÉES utiles pour la validation:
   - Attributs: required, pattern, min, max, minlength, maxlength
   - Types: email, url, tel, number, date

5. Une validation client PERSONNALISÉE et COMPLEXE peut être accomplie
   avec JAVASCRIPT:
   - Validation en temps réel
   - Messages personnalisés
   - Vérifications multi-champs

6. Les requêtes ASYNCHRONES au serveur peuvent effectuer des validations
   BACK-END avant qu'un formulaire ait été soumis:
   - Vérifier disponibilité username
   - Valider codes promo
   - Contrôler données en base

7. Une validation finale BACK-END de toutes les données est REQUISE pour:
   - Garantir la sécurité de l'application
   - Nettoyer (sanitize) toutes les données
   - Seule vraie protection contre les attaques

⚠️ RÈGLE ABSOLUE: Ne JAMAIS faire confiance aux données client!
                   Toujours valider et nettoyer côté serveur!


================================================================================
EXEMPLE COMPLET DE TRAITEMENT SÉCURISÉ
================================================================================

FORMULAIRE HTML COMPLET:

    <!DOCTYPE html>
    <html lang="fr">
    <head>
        <meta charset="UTF-8">
        <title>Inscription Sécurisée</title>
    </head>
    <body>
        <h1>Formulaire d'Inscription</h1>

        <form action="traitement_securise.php" method="POST">
            <!-- Nom -->
            <label for="nom">Nom:</label>
            <input type="text" name="nom" id="nom"
                   minlength="2" maxlength="50"
                   required />
            <br />

            <!-- Email -->
            <label for="email">Email:</label>
            <input type="email" name="email" id="email"
                   required />
            <br />

            <!-- Âge -->
            <label for="age">Âge:</label>
            <input type="number" name="age" id="age"
                   min="18" max="99"
                   required />
            <br />

            <!-- Bouton -->
            <button type="submit">S'inscrire</button>
        </form>
    </body>
    </html>

TRAITEMENT PHP SÉCURISÉ:

    <?php
    // traitement_securise.php

    if ($_SERVER["REQUEST_METHOD"] === "POST") {
        $erreurs = [];

        // VALIDATION
        if (empty($_POST["nom"])) {
            $erreurs[] = "Le nom est requis";
        } elseif (strlen($_POST["nom"]) < 2 || strlen($_POST["nom"]) > 50) {
            $erreurs[] = "Le nom doit contenir entre 2 et 50 caractères";
        }

        if (empty($_POST["email"])) {
            $erreurs[] = "L'email est requis";
        } elseif (!filter_var($_POST["email"], FILTER_VALIDATE_EMAIL)) {
            $erreurs[] = "Format d'email invalide";
        }

        if (empty($_POST["age"])) {
            $erreurs[] = "L'âge est requis";
        } elseif (!is_numeric($_POST["age"])) {
            $erreurs[] = "L'âge doit être un nombre";
        } elseif ($_POST["age"] < 18 || $_POST["age"] > 99) {
            $erreurs[] = "L'âge doit être entre 18 et 99";
        }

        // SANITIZATION
        $nom = htmlspecialchars(trim($_POST["nom"]));
        $email = filter_var($_POST["email"], FILTER_SANITIZE_EMAIL);
        $age = intval($_POST["age"]);

        // TRAITEMENT
        if (empty($erreurs)) {
            echo "<h2>Inscription réussie!</h2>";
            echo "<p>Nom: " . $nom . "</p>";
            echo "<p>Email: " . $email . "</p>";
            echo "<p>Âge: " . $age . "</p>";
            // Ici : insérer en base de données, envoyer email, etc.
        } else {
            echo "<h2>Erreurs de validation:</h2>";
            echo "<ul>";
            foreach ($erreurs as $erreur) {
                echo "<li style='color:red;'>$erreur</li>";
            }
            echo "</ul>";
            echo "<a href='javascript:history.back()'>Retour</a>";
        }
    } else {
        echo "Accès non autorisé";
    }
    ?>


================================================================================
POINTS ESSENTIELS À RETENIR
================================================================================

1. TOUJOURS valider côté serveur (PHP) - C'EST OBLIGATOIRE

2. La validation HTML5 et JavaScript améliore l'expérience utilisateur mais
   NE GARANTIT PAS la sécurité

3. Utiliser htmlspecialchars() pour afficher des données utilisateur

4. Utiliser filter_var() pour valider emails et URLs

5. Utiliser empty(), isset(), is_numeric() pour vérifier les données

6. JAMAIS faire confiance aux données provenant du client

7. Toujours nettoyer (sanitize) les données avant de les utiliser

8. Créer un array $erreurs pour collecter toutes les erreurs de validation

9. Afficher des messages d'erreur clairs et utiles à l'utilisateur

10. En production, utiliser HTTPS pour protéger les données sensibles


================================================================================
Fichier 8/8 - Guide PHP Complet
================================================================================
