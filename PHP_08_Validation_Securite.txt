================================================================================
              PHP MODULE 8 : VALIDATION ET SÉCURITÉ DES FORMULAIRES
================================================================================

TABLE DES MATIÈRES
==================
1. Sécurité et Validation - Introduction
2. Les Expressions Régulières (Regex)
3. Validation HTML5 Intégrée
4. Validation JavaScript Personnalisée
5. Validation Asynchrone (AJAX)
6. Validation Back-End (Serveur) - OBLIGATOIRE
7. Stratégie de Validation Complète
8. Récapitulatif - Validation de Formulaires


================================================================================
H. SÉCURITÉ ET VALIDATION
================================================================================

⚠️ TRÈS IMPORTANT: TOUJOURS valider et nettoyer les données utilisateur!

Les données de $_GET, $_POST, $_REQUEST proviennent de l'utilisateur et
peuvent être DANGEREUSES (injection SQL, XSS, etc.).

EXEMPLE - Validation basique:

    <?php
    // ✗ DANGER - Jamais faire ça:
    echo $_POST["nom"];

    // ✓ MIEUX - Nettoyer les données:
    $nom = htmlspecialchars($_POST["nom"]);
    echo $nom;

    // ✓ ENCORE MIEUX - Vérifier l'existence:
    if (isset($_POST["nom"]) && !empty($_POST["nom"])) {
        $nom = htmlspecialchars($_POST["nom"]);
        echo $nom;
    } else {
        echo "Nom manquant!";
    }
    ?>

FONCTIONS DE SÉCURITÉ IMPORTANTES:
- htmlspecialchars() : Échappe les caractères HTML (prévient XSS)
- isset()            : Vérifie si la variable existe
- empty()            : Vérifie si la variable est vide
- filter_input()     : Filtre et valide les données entrantes


================================================================================
H-bis. VALIDATION DE FORMULAIRES - RÉCAPITULATIF COMPLET
================================================================================

INTRODUCTION:
La validation de formulaires est ESSENTIELLE pour la sécurité et le bon
fonctionnement des sites web. Les sites modernes collectent beaucoup
d'informations via les formulaires HTML et doivent s'assurer que ces
données sont valides et sécurisées.

1. POURQUOI VALIDER LES FORMULAIRES ?
--------------------------------------

Les sites web modernes nécessitent beaucoup d'informations de leurs
utilisateurs et collectent ces données principalement via des formulaires HTML.

RAISONS ESSENTIELLES:
✓ SÉCURITÉ: Protéger contre les attaques (injection SQL, XSS, etc.)
✓ INTÉGRITÉ: Garantir que les données sont dans le bon format
✓ FONCTIONNEMENT: Assurer que l'application fonctionne correctement
✓ EXPÉRIENCE: Guider l'utilisateur en cas d'erreur de saisie

⚠️ RÈGLE D'OR: Toujours valider côté client ET côté serveur!


================================================================================
2. LES EXPRESSIONS RÉGULIÈRES (REGEX)
================================================================================

DÉFINITION:
Les expressions régulières (regex) sont des SÉQUENCES DE CARACTÈRES qui
définissent des MOTIFS (patterns) à rechercher dans du texte. Elles sont
un outil important pour valider les données saisies.

USAGE EN VALIDATION:
- Vérifier le format d'un email
- Valider un numéro de téléphone
- Contrôler un code postal
- Vérifier la force d'un mot de passe

EXEMPLES DE REGEX COURANTES:

Email basique:
    /^[a-zA-Z0-9._-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/

Numéro de téléphone français (10 chiffres):
    /^0[1-9][0-9]{8}$/

Code postal français:
    /^[0-9]{5}$/

Mot de passe fort (min 8 caractères, lettres + chiffres):
    /^(?=.*[A-Za-z])(?=.*\d)[A-Za-z\d]{8,}$/

UTILISATION EN HTML:
    <input type="tel" name="telephone"
           pattern="0[1-9][0-9]{8}"
           title="Format: 0612345678" />


================================================================================
3. VALIDATION HTML5 INTÉGRÉE
================================================================================

HTML5 offre des méthodes INTÉGRÉES très utiles pour la validation côté client.

A) ATTRIBUTS DE VALIDATION HTML5:

required - Champ obligatoire:
    <input type="text" name="nom" required />

minlength / maxlength - Longueur du texte:
    <input type="text" name="username"
           minlength="3" maxlength="20" />

min / max - Valeurs numériques:
    <input type="number" name="age"
           min="18" max="99" />

pattern - Expression régulière:
    <input type="text" name="code_postal"
           pattern="[0-9]{5}"
           title="Code postal à 5 chiffres" />

B) TYPES INPUT AVEC VALIDATION AUTOMATIQUE:

type="email" - Valide le format email:
    <input type="email" name="email" required />
    <!-- Refuse: "test" ou "test@" -->
    <!-- Accepte: "test@example.com" -->

type="url" - Valide le format URL:
    <input type="url" name="site" />
    <!-- Accepte: "https://example.com" -->

type="tel" - Pour téléphone (pas de validation auto):
    <input type="tel" name="tel" pattern="[0-9]{10}" />

type="number" - Seulement des nombres:
    <input type="number" name="quantite" min="1" />

C) MESSAGES D'ERREUR PERSONNALISÉS:

Utiliser l'attribut "title" pour guider l'utilisateur:
    <input type="text" name="cp"
           pattern="[0-9]{5}"
           title="Le code postal doit contenir exactement 5 chiffres"
           required />

AVANTAGES DE LA VALIDATION HTML5:
✓ Aucun JavaScript nécessaire
✓ Messages d'erreur automatiques
✓ Empêche la soumission si invalide
✓ Retour instantané à l'utilisateur

LIMITATIONS:
✗ Peut être contournée (désactivation JavaScript, modification HTML)
✗ Messages parfois pas assez clairs
✗ NE REMPLACE PAS la validation serveur!


================================================================================
4. VALIDATION JAVASCRIPT PERSONNALISÉE
================================================================================

Pour des validations plus COMPLEXES ou PERSONNALISÉES, JavaScript est nécessaire.

A) VALIDATION EN TEMPS RÉEL:

Valider pendant la saisie:
    <input type="text" id="username" name="username" />

    <script>
    const usernameInput = document.getElementById('username');

    usernameInput.addEventListener('input', function() {
        if (this.value.length < 3) {
            this.setCustomValidity('Minimum 3 caractères requis');
        } else {
            this.setCustomValidity('');  // Valide
        }
    });
    </script>

B) VALIDATION AVANT SOUMISSION:

Vérifier avant d'envoyer:
    <form id="monForm" onsubmit="return validerFormulaire()">
        <input type="password" id="mdp" name="mdp" />
        <input type="password" id="mdp2" name="mdp2" />
        <button type="submit">S'inscrire</button>
    </form>

    <script>
    function validerFormulaire() {
        const mdp1 = document.getElementById('mdp').value;
        const mdp2 = document.getElementById('mdp2').value;

        if (mdp1 !== mdp2) {
            alert('Les mots de passe ne correspondent pas!');
            return false;  // Empêche la soumission
        }

        return true;  // Autorise la soumission
    }
    </script>

C) VALIDATION COMPLEXE:

Vérifier la force d'un mot de passe:
    <input type="password" id="password" />
    <p id="force"></p>

    <script>
    const passwordInput = document.getElementById('password');
    const forceText = document.getElementById('force');

    passwordInput.addEventListener('input', function() {
        const mdp = this.value;
        let force = 0;

        // Critères de force
        if (mdp.length >= 8) force++;
        if (/[a-z]/.test(mdp)) force++;      // Minuscules
        if (/[A-Z]/.test(mdp)) force++;      // Majuscules
        if (/[0-9]/.test(mdp)) force++;      // Chiffres
        if (/[^A-Za-z0-9]/.test(mdp)) force++; // Caractères spéciaux

        // Affichage
        if (force < 2) forceText.textContent = 'Faible';
        else if (force < 4) forceText.textContent = 'Moyen';
        else forceText.textContent = 'Fort';
    });
    </script>

AVANTAGES JAVASCRIPT:
✓ Validation personnalisée complexe
✓ Retour visuel immédiat
✓ Meilleure expérience utilisateur
✓ Peut vérifier plusieurs champs ensemble

LIMITATIONS:
✗ Peut être désactivé par l'utilisateur
✗ Ne garantit PAS la sécurité
✗ Doit être doublée par validation serveur


================================================================================
5. VALIDATION ASYNCHRONE (AJAX)
================================================================================

Les requêtes ASYNCHRONES au serveur permettent de valider des données
AVANT la soumission du formulaire, sans recharger la page.

USAGE TYPIQUE:
- Vérifier si un nom d'utilisateur est déjà pris
- Valider un code promo en temps réel
- Vérifier si un email existe dans la base de données

EXEMPLE - Vérifier disponibilité d'un username:

HTML:
    <input type="text" id="username" name="username" />
    <span id="message"></span>

JAVASCRIPT (avec Fetch API):
    <script>
    const usernameInput = document.getElementById('username');
    const messageSpan = document.getElementById('message');

    usernameInput.addEventListener('blur', function() {
        const username = this.value;

        // Requête asynchrone au serveur
        fetch('verifier_username.php?username=' + username)
            .then(response => response.json())
            .then(data => {
                if (data.disponible) {
                    messageSpan.textContent = '✓ Disponible';
                    messageSpan.style.color = 'green';
                } else {
                    messageSpan.textContent = '✗ Déjà pris';
                    messageSpan.style.color = 'red';
                }
            });
    });
    </script>

FICHIER PHP: verifier_username.php
    <?php
    $username = $_GET['username'];

    // Vérifier dans la base de données (exemple simplifié)
    $usernames_pris = ['admin', 'test', 'user'];
    $disponible = !in_array($username, $usernames_pris);

    // Retourner JSON
    header('Content-Type: application/json');
    echo json_encode(['disponible' => $disponible]);
    ?>

AVANTAGES:
✓ Validation en temps réel sans recharger la page
✓ Utilise les données du serveur (base de données)
✓ Meilleure expérience utilisateur
✓ Détecte les problèmes avant soumission

LIMITATIONS:
✗ Requiert JavaScript activé
✗ Nécessite une connexion internet
✗ Ne remplace PAS la validation finale


================================================================================
6. VALIDATION BACK-END (SERVEUR) - OBLIGATOIRE
================================================================================

⚠️ CRUCIAL: Une validation finale BACK-END de TOUTES les données est
OBLIGATOIRE pour garantir la sécurité de l'application!

POURQUOI C'EST ESSENTIEL:

1. La validation client peut être CONTOURNÉE:
   - JavaScript peut être désactivé
   - L'HTML peut être modifié (DevTools)
   - Des requêtes peuvent être envoyées directement (curl, Postman)

2. La validation serveur est LA SEULE GARANTIE de sécurité

EXEMPLE COMPLET - Validation PHP côté serveur:

    <?php
    // Réception des données
    if ($_SERVER["REQUEST_METHOD"] === "POST") {

        $erreurs = [];

        // 1. VALIDATION - Nom (requis, 2-50 caractères)
        if (empty($_POST["nom"])) {
            $erreurs[] = "Le nom est requis";
        } elseif (strlen($_POST["nom"]) < 2 || strlen($_POST["nom"]) > 50) {
            $erreurs[] = "Le nom doit contenir entre 2 et 50 caractères";
        }

        // 2. VALIDATION - Email (requis, format valide)
        if (empty($_POST["email"])) {
            $erreurs[] = "L'email est requis";
        } elseif (!filter_var($_POST["email"], FILTER_VALIDATE_EMAIL)) {
            $erreurs[] = "Format d'email invalide";
        }

        // 3. VALIDATION - Âge (requis, entre 18 et 99)
        if (empty($_POST["age"])) {
            $erreurs[] = "L'âge est requis";
        } elseif (!is_numeric($_POST["age"])) {
            $erreurs[] = "L'âge doit être un nombre";
        } elseif ($_POST["age"] < 18 || $_POST["age"] > 99) {
            $erreurs[] = "L'âge doit être entre 18 et 99";
        }

        // 4. SANITIZATION - Nettoyer les données
        $nom = htmlspecialchars(trim($_POST["nom"]));
        $email = filter_var($_POST["email"], FILTER_SANITIZE_EMAIL);
        $age = intval($_POST["age"]);

        // 5. TRAITEMENT - Si pas d'erreurs
        if (empty($erreurs)) {
            // Données valides et nettoyées
            // Insérer en base de données, envoyer email, etc.
            echo "Inscription réussie!";
        } else {
            // Afficher les erreurs
            foreach ($erreurs as $erreur) {
                echo "<p style='color:red;'>$erreur</p>";
            }
        }
    }
    ?>

FONCTIONS PHP IMPORTANTES:

VALIDATION:
- empty()                : Vérifie si vide
- is_numeric()           : Vérifie si nombre
- filter_var()           : Valide email, URL, etc.
- preg_match()           : Vérifie regex
- strlen()               : Longueur de chaîne

SANITIZATION (NETTOYAGE):
- htmlspecialchars()     : Échappe HTML (prévient XSS)
- trim()                 : Retire espaces début/fin
- strip_tags()           : Retire balises HTML
- filter_var()           : Nettoie email, URL, etc.
- intval()               : Convertit en entier
- floatval()             : Convertit en décimal


================================================================================
7. STRATÉGIE DE VALIDATION COMPLÈTE
================================================================================

Pour une sécurité optimale, utilisez PLUSIEURS NIVEAUX de validation:

NIVEAU 1 - VALIDATION HTML5 (Côté client):
✓ Validation de base instantanée
✓ Attributs: required, pattern, min, max, etc.
✓ Types: email, url, number, etc.
→ Améliore l'expérience utilisateur

NIVEAU 2 - VALIDATION JAVASCRIPT (Côté client):
✓ Validations personnalisées complexes
✓ Retour visuel en temps réel
✓ Vérification de cohérence entre champs
→ Guide l'utilisateur avant soumission

NIVEAU 3 - VALIDATION ASYNCHRONE (Client → Serveur):
✓ Vérifications nécessitant les données serveur
✓ Disponibilité username, code promo, etc.
✓ Avant la soumission finale
→ Détecte les problèmes tôt

NIVEAU 4 - VALIDATION BACK-END (Serveur) ⚠️ OBLIGATOIRE:
✓ Validation COMPLÈTE de toutes les données
✓ Sanitization (nettoyage) de toutes les données
✓ Seule vraie garantie de sécurité
→ Protection finale et indispensable

FLUX COMPLET:
    1. Utilisateur saisit → HTML5 valide instantanément
    2. Utilisateur continue → JavaScript valide en temps réel
    3. Avant soumission → AJAX vérifie avec serveur si nécessaire
    4. Soumission → PHP valide et nettoie TOUT côté serveur
    5. Traitement → Données sûres et valides


================================================================================
8. RÉCAPITULATIF - VALIDATION DE FORMULAIRES
================================================================================

POINTS CLÉS À RETENIR:

1. Les sites web modernes collectent beaucoup d'informations via
   des formulaires HTML

2. Il est ESSENTIEL de valider les données soumises pour:
   - Maintenir la sécurité des sites
   - Garantir le bon fonctionnement

3. Les EXPRESSIONS RÉGULIÈRES (regex) sont des séquences de caractères
   qui définissent des motifs à rechercher dans du texte
   - Outil important pour valider les données saisies

4. HTML5 moderne offre des méthodes INTÉGRÉES utiles pour la validation:
   - Attributs: required, pattern, min, max, minlength, maxlength
   - Types: email, url, tel, number, date

5. Une validation client PERSONNALISÉE et COMPLEXE peut être accomplie
   avec JAVASCRIPT:
   - Validation en temps réel
   - Messages personnalisés
   - Vérifications multi-champs

6. Les requêtes ASYNCHRONES au serveur peuvent effectuer des validations
   BACK-END avant qu'un formulaire ait été soumis:
   - Vérifier disponibilité username
   - Valider codes promo
   - Contrôler données en base

7. Une validation finale BACK-END de toutes les données est REQUISE pour:
   - Garantir la sécurité de l'application
   - Nettoyer (sanitize) toutes les données
   - Seule vraie protection contre les attaques

⚠️ RÈGLE ABSOLUE: Ne JAMAIS faire confiance aux données client!
                   Toujours valider et nettoyer côté serveur!


================================================================================
EXEMPLE COMPLET DE TRAITEMENT SÉCURISÉ
================================================================================

FORMULAIRE HTML COMPLET:

    <!DOCTYPE html>
    <html lang="fr">
    <head>
        <meta charset="UTF-8">
        <title>Inscription Sécurisée</title>
    </head>
    <body>
        <h1>Formulaire d'Inscription</h1>

        <form action="traitement_securise.php" method="POST">
            <!-- Nom -->
            <label for="nom">Nom:</label>
            <input type="text" name="nom" id="nom"
                   minlength="2" maxlength="50"
                   required />
            <br />

            <!-- Email -->
            <label for="email">Email:</label>
            <input type="email" name="email" id="email"
                   required />
            <br />

            <!-- Âge -->
            <label for="age">Âge:</label>
            <input type="number" name="age" id="age"
                   min="18" max="99"
                   required />
            <br />

            <!-- Bouton -->
            <button type="submit">S'inscrire</button>
        </form>
    </body>
    </html>

TRAITEMENT PHP SÉCURISÉ:

    <?php
    // traitement_securise.php

    if ($_SERVER["REQUEST_METHOD"] === "POST") {
        $erreurs = [];

        // VALIDATION
        if (empty($_POST["nom"])) {
            $erreurs[] = "Le nom est requis";
        } elseif (strlen($_POST["nom"]) < 2 || strlen($_POST["nom"]) > 50) {
            $erreurs[] = "Le nom doit contenir entre 2 et 50 caractères";
        }

        if (empty($_POST["email"])) {
            $erreurs[] = "L'email est requis";
        } elseif (!filter_var($_POST["email"], FILTER_VALIDATE_EMAIL)) {
            $erreurs[] = "Format d'email invalide";
        }

        if (empty($_POST["age"])) {
            $erreurs[] = "L'âge est requis";
        } elseif (!is_numeric($_POST["age"])) {
            $erreurs[] = "L'âge doit être un nombre";
        } elseif ($_POST["age"] < 18 || $_POST["age"] > 99) {
            $erreurs[] = "L'âge doit être entre 18 et 99";
        }

        // SANITIZATION
        $nom = htmlspecialchars(trim($_POST["nom"]));
        $email = filter_var($_POST["email"], FILTER_SANITIZE_EMAIL);
        $age = intval($_POST["age"]);

        // TRAITEMENT
        if (empty($erreurs)) {
            echo "<h2>Inscription réussie!</h2>";
            echo "<p>Nom: " . $nom . "</p>";
            echo "<p>Email: " . $email . "</p>";
            echo "<p>Âge: " . $age . "</p>";
            // Ici : insérer en base de données, envoyer email, etc.
        } else {
            echo "<h2>Erreurs de validation:</h2>";
            echo "<ul>";
            foreach ($erreurs as $erreur) {
                echo "<li style='color:red;'>$erreur</li>";
            }
            echo "</ul>";
            echo "<a href='javascript:history.back()'>Retour</a>";
        }
    } else {
        echo "Accès non autorisé";
    }
    ?>


================================================================================
POINTS ESSENTIELS À RETENIR
================================================================================

1. TOUJOURS valider côté serveur (PHP) - C'EST OBLIGATOIRE

2. La validation HTML5 et JavaScript améliore l'expérience utilisateur mais
   NE GARANTIT PAS la sécurité

3. Utiliser htmlspecialchars() pour afficher des données utilisateur

4. Utiliser filter_var() pour valider emails et URLs

5. Utiliser empty(), isset(), is_numeric() pour vérifier les données

6. JAMAIS faire confiance aux données provenant du client

7. Toujours nettoyer (sanitize) les données avant de les utiliser

8. Créer un array $erreurs pour collecter toutes les erreurs de validation

9. Afficher des messages d'erreur clairs et utiles à l'utilisateur

10. En production, utiliser HTTPS pour protéger les données sensibles


================================================================================
Fichier 8/8 - Guide PHP Complet
================================================================================
