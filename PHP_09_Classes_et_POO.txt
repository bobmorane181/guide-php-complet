================================================================================
         PHP MODULE 9 : CLASSES ET PROGRAMMATION ORIENTÃ‰E OBJET (POO)
================================================================================

TABLE DES MATIÃˆRES
==================
1. Qu'est-ce que la POO ?
2. Classes et Objets - Les Fondamentaux
3. CrÃ©er sa PremiÃ¨re Classe
4. PropriÃ©tÃ©s - Les DonnÃ©es d'un Objet
5. MÃ©thodes - Les Actions d'un Objet
6. Modificateurs d'AccÃ¨s (public, private, protected)
7. Le Constructeur - Initialiser un Objet
8. $this - RÃ©fÃ©rencer l'Objet Actuel
9. L'HÃ©ritage - RÃ©utiliser du Code
10. Exemple Pratique Complet
11. Points ClÃ©s Ã  Retenir


================================================================================
A. QU'EST-CE QUE LA POO ?
================================================================================

POO = PROGRAMMATION ORIENTÃ‰E OBJET (Object-Oriented Programming)

DÃ‰FINITION :
La POO est une maniÃ¨re d'organiser et de structurer votre code en utilisant
des "objets" qui reprÃ©sentent des Ã©lÃ©ments du monde rÃ©el ou des concepts.

Au lieu d'avoir du code Ã©parpillÃ© (approche procÃ©durale), vous regroupez les
donnÃ©es et les actions qui vont ensemble dans des "objets".


ANALOGIE DU MONDE RÃ‰EL :
------------------------
Pensez Ã  une VOITURE :
- Elle a des CARACTÃ‰RISTIQUES : couleur, marque, vitesse maximale, niveau
  d'essence
- Elle peut FAIRE DES CHOSES : dÃ©marrer, accÃ©lÃ©rer, freiner, klaxonner

En POO, vous crÃ©ez un "plan" (une classe) pour construire des voitures
(des objets).


COMPARAISON : CODE PROCÃ‰DURAL vs POO
-------------------------------------

// âŒ SANS POO (code Ã©parpillÃ©)
$nom_utilisateur = "Marie";
$email_utilisateur = "marie@example.com";
$age_utilisateur = 28;

function envoyer_email_utilisateur($email) {
    echo "Email envoyÃ© Ã  : $email\n";
}

function afficher_utilisateur($nom, $email, $age) {
    echo "Nom: $nom, Email: $email, Age: $age\n";
}

envoyer_email_utilisateur($email_utilisateur);
afficher_utilisateur($nom_utilisateur, $email_utilisateur, $age_utilisateur);


// âœ… AVEC POO (code organisÃ©)
class Utilisateur {
    public $nom;
    public $email;
    public $age;

    public function envoyerEmail() {
        echo "Email envoyÃ© Ã  : $this->email\n";
    }

    public function afficher() {
        echo "Nom: $this->nom, Email: $this->email, Age: $this->age\n";
    }
}

$utilisateur = new Utilisateur();
$utilisateur->nom = "Marie";
$utilisateur->email = "marie@example.com";
$utilisateur->age = 28;

$utilisateur->envoyerEmail();
$utilisateur->afficher();


VOCABULAIRE DE BASE :
---------------------
â€¢ CLASSE     : Le plan, le modÃ¨le (comme un plan de maison)
â€¢ OBJET      : Une instance crÃ©Ã©e Ã  partir d'une classe (une maison construite)
â€¢ INSTANCE   : Synonyme d'objet (un exemplaire de la classe)
â€¢ PROPRIÃ‰TÃ‰  : Variable Ã  l'intÃ©rieur d'une classe (les caractÃ©ristiques)
â€¢ MÃ‰THODE    : Fonction Ã  l'intÃ©rieur d'une classe (les actions)


POURQUOI UTILISER LA POO ?
---------------------------
âœ“ Organisation : Code structurÃ© et facile Ã  maintenir
âœ“ RÃ©utilisation : CrÃ©er plusieurs objets Ã  partir d'une mÃªme classe
âœ“ Encapsulation : ProtÃ©ger les donnÃ©es sensibles
âœ“ HÃ©ritage : RÃ©utiliser du code existant
âœ“ ClartÃ© : Code qui reflÃ¨te le monde rÃ©el


================================================================================
B. CLASSES ET OBJETS - LES FONDAMENTAUX
================================================================================

CONCEPT CLÃ‰ : CLASSE vs OBJET
------------------------------

Une CLASSE est comme un PLAN DE MAISON :
- C'est un modÃ¨le, un blueprint
- Elle dÃ©finit la structure mais n'existe pas physiquement
- Elle dÃ©crit ce qu'un objet aura et pourra faire

Un OBJET est comme une MAISON CONSTRUITE :
- C'est une rÃ©alisation concrÃ¨te du plan
- Il existe en mÃ©moire
- Vous pouvez crÃ©er plusieurs objets (maisons) Ã  partir d'une classe (plan)


SCHÃ‰MA VISUEL :
---------------

    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
    â”‚   Classe: Voiture         â”‚  â† Le PLAN (dÃ©finition)
    â”‚   â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€       â”‚
    â”‚   PropriÃ©tÃ©s:             â”‚
    â”‚   - $couleur              â”‚
    â”‚   - $marque               â”‚
    â”‚   - $vitesse              â”‚
    â”‚                           â”‚
    â”‚   MÃ©thodes:               â”‚
    â”‚   - demarrer()            â”‚
    â”‚   - accelerer()           â”‚
    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                â”‚
                â”‚ new Voiture()
                â”‚
                â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                â”‚                                                    â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Objet 1        â”‚        â”‚ Objet 2      â”‚        â”‚ Objet 3         â”‚
        â”‚ â”€â”€â”€â”€â”€â”€         â”‚        â”‚ â”€â”€â”€â”€â”€â”€       â”‚        â”‚ â”€â”€â”€â”€â”€â”€          â”‚
        â”‚ Voiture rouge  â”‚        â”‚ Voiture      â”‚        â”‚ Voiture noire   â”‚
        â”‚ Toyota         â”‚        â”‚ bleue Honda  â”‚        â”‚ Ford            â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


EXEMPLE DE CODE :
-----------------

<?php
// DÃ©finir une CLASSE (le plan)
class Voiture {
    // Le contenu viendra plus tard
}

// CrÃ©er des OBJETS (instances)
$voiture1 = new Voiture();  // Premier objet
$voiture2 = new Voiture();  // DeuxiÃ¨me objet (indÃ©pendant)
$voiture3 = new Voiture();  // TroisiÃ¨me objet (indÃ©pendant)

// VÃ©rifier que ce sont des objets diffÃ©rents
var_dump($voiture1 === $voiture2);  // false (objets diffÃ©rents en mÃ©moire)
?>


Ã€ RETENIR :
-----------
â€¢ Une classe se dÃ©finit UNE SEULE FOIS
â€¢ Vous pouvez crÃ©er AUTANT d'objets que vous voulez Ã  partir de cette classe
â€¢ Chaque objet est INDÃ‰PENDANT (modifier l'un n'affecte pas les autres)
â€¢ Le mot-clÃ© "new" crÃ©e un nouvel objet


================================================================================
C. CRÃ‰ER SA PREMIÃˆRE CLASSE
================================================================================

SYNTAXE DE BASE :
-----------------

    class NomDeLaClasse {
        // Contenu de la classe
    }

âš ï¸ IMPORTANT :
Les classes sont dÃ©finies avec le mot-clÃ© "class", un mot-clÃ© rÃ©servÃ© de PHP.
Ce mot-clÃ© indique au moteur PHP que vous dÃ©finissez une nouvelle classe.


CONVENTION DE NOMMAGE :
-----------------------
Les classes utilisent la convention PascalCase (aussi appelÃ©e UpperCamelCase) :
- PremiÃ¨re lettre en MAJUSCULE
- Chaque mot commence par une majuscule
- Pas d'underscore

âœ… CORRECT :
    class Utilisateur
    class CompteBancaire
    class VoitureElectrique

âŒ INCORRECT :
    class utilisateur        // Pas de majuscule
    class compte_bancaire    // Snake_case (pour les fonctions, pas les classes)
    class voiture-electrique // Tirets non autorisÃ©s


EXEMPLE 1 : CLASSE VIDE
------------------------

<?php
// 1. DÃ©finir une classe vide
class Chien {
    // Vide pour l'instant
}

// 2. CrÃ©er un objet
$mon_chien = new Chien();

// 3. VÃ©rifier le type
var_dump($mon_chien);
// Affiche : object(Chien)#1 (0) {}
?>


EXEMPLE 2 : CRÃ‰ER PLUSIEURS OBJETS
-----------------------------------

<?php
class Chat {
    // Classe vide pour l'instant
}

// CrÃ©er plusieurs chats indÃ©pendants
$chat1 = new Chat();
$chat2 = new Chat();
$chat3 = new Chat();

echo "chat1 : ";
var_dump($chat1);  // object(Chat)#1

echo "chat2 : ";
var_dump($chat2);  // object(Chat)#2 (numÃ©ro diffÃ©rent !)

// Comparer les objets
var_dump($chat1 === $chat2);  // false - objets diffÃ©rents
var_dump($chat1 == $chat2);   // true - mÃªme structure
?>


LE MOT-CLÃ‰ "new" :
------------------
â€¢ new crÃ©e une NOUVELLE INSTANCE de la classe
â€¢ Chaque appel Ã  new crÃ©e un objet DISTINCT en mÃ©moire
â€¢ Sans new, vous avez juste le nom de la classe, pas un objet


ERREURS COURANTES :
-------------------

// âŒ ERREUR : Oublier le mot-clÃ© "new"
$chien = Chien();
// Fatal error: Uncaught Error: Call to undefined function Chien()

// âŒ ERREUR : Utiliser une classe qui n'existe pas
$animal = new Licorne();
// Fatal error: Uncaught Error: Class 'Licorne' not found

// âœ… CORRECT : Utiliser new avec une classe dÃ©finie
$chien = new Chien();


POINT CLÃ‰ :
-----------
Ã€ ce stade, nos classes sont vides, mais elles fonctionnent ! Dans les
prochaines sections, nous ajouterons des propriÃ©tÃ©s (donnÃ©es) et des
mÃ©thodes (actions) pour rendre nos objets utiles.


================================================================================
D. PROPRIÃ‰TÃ‰S - LES DONNÃ‰ES D'UN OBJET
================================================================================

QU'EST-CE QU'UNE PROPRIÃ‰TÃ‰ ?
-----------------------------
Une propriÃ©tÃ© est une VARIABLE Ã  l'intÃ©rieur d'une classe. Elle stocke les
donnÃ©es spÃ©cifiques Ã  chaque objet.

ğŸ’¡ TRANSFORMATION TERMINOLOGIQUE :
Lorsqu'une variable est dÃ©finie Ã  l'intÃ©rieur d'une classe, elle devient une
**propriÃ©tÃ©**. C'est le mÃªme concept, mais le terme change selon le contexte :
- Hors classe : on parle de "variable"
- Dans classe : on parle de "propriÃ©tÃ©"

SYNTAXE :
    public $nomPropriete;


EXEMPLE 1 : DÃ‰FINIR DES PROPRIÃ‰TÃ‰S
-----------------------------------

<?php
class Utilisateur {
    public $nom;      // PropriÃ©tÃ© pour le nom
    public $age;      // PropriÃ©tÃ© pour l'Ã¢ge
    public $email;    // PropriÃ©tÃ© pour l'email
}

// CrÃ©er un objet
$user1 = new Utilisateur();

// Assigner des valeurs aux propriÃ©tÃ©s (opÃ©rateur ->)
$user1->nom = "Alice";
$user1->age = 25;
$user1->email = "alice@example.com";

// Lire les propriÃ©tÃ©s
echo $user1->nom;   // Affiche : Alice
echo $user1->age;   // Affiche : 25
echo $user1->email; // Affiche : alice@example.com
?>


L'OPÃ‰RATEUR FLÃˆCHE (->) :
--------------------------
Pour accÃ©der aux propriÃ©tÃ©s d'un objet, on utilise -> (flÃ¨che) :

    $objet->propriete

âš ï¸ IMPORTANT : Notez qu'on N'utilise PAS le $ devant le nom de la propriÃ©tÃ©
aprÃ¨s la flÃ¨che !

âœ… CORRECT :
    $user->nom

âŒ INCORRECT :
    $user->$nom     // Double $ non nÃ©cessaire


EXEMPLE 2 : OBJETS INDÃ‰PENDANTS
--------------------------------

<?php
class Produit {
    public $nom;
    public $prix;
}

// CrÃ©er deux produits diffÃ©rents
$produit1 = new Produit();
$produit1->nom = "Laptop";
$produit1->prix = 1200;

$produit2 = new Produit();
$produit2->nom = "Souris";
$produit2->prix = 25;

// Chaque objet a ses propres valeurs
echo $produit1->nom . " : " . $produit1->prix . "â‚¬\n";  // Laptop : 1200â‚¬
echo $produit2->nom . " : " . $produit2->prix . "â‚¬\n";  // Souris : 25â‚¬

// Modifier un objet n'affecte pas l'autre
$produit1->prix = 1000;
echo $produit2->prix;  // Toujours 25 (inchangÃ©)
?>


TABLEAU COMPARATIF : VARIABLE vs PROPRIÃ‰TÃ‰
-------------------------------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      â”‚ Variable simple     â”‚ PropriÃ©tÃ© de classe      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ DÃ©claration          â”‚ $nom = "Alice";     â”‚ public $nom;             â”‚
â”‚                      â”‚                     â”‚                          â”‚
â”‚ PortÃ©e               â”‚ Locale/globale      â”‚ LiÃ©e Ã  l'objet           â”‚
â”‚                      â”‚                     â”‚                          â”‚
â”‚ AccÃ¨s                â”‚ echo $nom;          â”‚ echo $objet->nom;        â”‚
â”‚                      â”‚                     â”‚                          â”‚
â”‚ Modificateur         â”‚ Aucun               â”‚ public, private,         â”‚
â”‚                      â”‚                     â”‚ protected                â”‚
â”‚                      â”‚                     â”‚                          â”‚
â”‚ DurÃ©e de vie         â”‚ Fin du script       â”‚ Tant que l'objet existe  â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


VALEURS PAR DÃ‰FAUT :
--------------------

Vous pouvez assigner des valeurs par dÃ©faut aux propriÃ©tÃ©s :

<?php
class Compteur {
    public $valeur = 0;        // Valeur par dÃ©faut : 0
    public $nom = "Compteur";  // Valeur par dÃ©faut : "Compteur"
}

$c1 = new Compteur();
echo $c1->valeur;  // 0 (valeur par dÃ©faut)

$c1->valeur = 10;  // Modifier la valeur
echo $c1->valeur;  // 10
?>


PROPRIÃ‰TÃ‰S NON INITIALISÃ‰ES :
------------------------------

<?php
class Personne {
    public $nom;  // Pas de valeur par dÃ©faut
}

$p = new Personne();
echo $p->nom;  // âš ï¸ Affiche rien (null) - Peut causer un Warning
?>

ğŸ’¡ BONNE PRATIQUE :
Toujours initialiser vos propriÃ©tÃ©s, soit avec une valeur par dÃ©faut, soit
via un constructeur (nous verrons cela dans la section G).


ERREURS COURANTES :
-------------------

// âŒ ERREUR : Oublier la flÃ¨che ->
$user = new Utilisateur();
echo $user.nom;  // Parse error

// âŒ ERREUR : AccÃ©der Ã  une propriÃ©tÃ© qui n'existe pas
$user = new Utilisateur();
echo $user->telephone;  // Warning: Undefined property

// âŒ ERREUR : Utiliser $ aprÃ¨s la flÃ¨che
echo $user->$nom;  // Erreur (sauf cas avancÃ©s)

// âœ… CORRECT :
echo $user->nom;


================================================================================
E. MÃ‰THODES - LES ACTIONS D'UN OBJET
================================================================================

QU'EST-CE QU'UNE MÃ‰THODE ?
---------------------------
Une mÃ©thode est une FONCTION Ã  l'intÃ©rieur d'une classe. Elle dÃ©finit les
actions qu'un objet peut effectuer.

ğŸ’¡ TRANSFORMATION TERMINOLOGIQUE :
Lorsqu'une fonction est dÃ©finie Ã  l'intÃ©rieur d'une classe, elle devient une
**mÃ©thode**. C'est le mÃªme concept, mais le terme change selon le contexte :
- Hors classe : on parle de "fonction"
- Dans classe : on parle de "mÃ©thode"

SYNTAXE :
    public function nomMethode() {
        // Code de la mÃ©thode
    }


EXEMPLE 1 : MÃ‰THODE SIMPLE
---------------------------

<?php
class Chien {
    public $nom;

    public function aboyer() {
        echo "Woof! Woof!\n";
    }
}

$chien = new Chien();
$chien->nom = "Rex";
$chien->aboyer();  // Affiche : Woof! Woof!
?>


APPELER UNE MÃ‰THODE :
---------------------
Comme pour les propriÃ©tÃ©s, on utilise la flÃ¨che -> :

    $objet->methode();

âš ï¸ ATTENTION : N'oubliez pas les parenthÃ¨ses () mÃªme si la mÃ©thode n'a pas
de paramÃ¨tres !


EXEMPLE 2 : MÃ‰THODE AVEC PARAMÃˆTRES
------------------------------------

<?php
class Calculatrice {
    public function additionner($a, $b) {
        return $a + $b;
    }

    public function multiplier($a, $b) {
        return $a * $b;
    }
}

$calc = new Calculatrice();

$resultat1 = $calc->additionner(5, 3);
echo $resultat1;  // 8

$resultat2 = $calc->multiplier(4, 7);
echo $resultat2;  // 28
?>


EXEMPLE 3 : MÃ‰THODE AVEC RETURN
--------------------------------

<?php
class Rectangle {
    public $largeur;
    public $hauteur;

    public function calculerAire() {
        return $this->largeur * $this->hauteur;
    }

    public function calculerPerimetre() {
        return 2 * ($this->largeur + $this->hauteur);
    }
}

$rect = new Rectangle();
$rect->largeur = 10;
$rect->hauteur = 5;

echo "Aire : " . $rect->calculerAire() . "\n";        // 50
echo "PÃ©rimÃ¨tre : " . $rect->calculerPerimetre() . "\n";  // 30
?>

Note : Nous utilisons $this dans cet exemple - nous l'expliquerons en dÃ©tail
dans la section H.


TABLEAU COMPARATIF : FONCTION vs MÃ‰THODE
-----------------------------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    â”‚ Fonction             â”‚ MÃ©thode                â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ OÃ¹ ?               â”‚ Hors d'une classe    â”‚ Ã€ l'intÃ©rieur d'une    â”‚
â”‚                    â”‚                      â”‚ classe                 â”‚
â”‚                    â”‚                      â”‚                        â”‚
â”‚ DÃ©claration        â”‚ function test() {}   â”‚ public function        â”‚
â”‚                    â”‚                      â”‚ test() {}              â”‚
â”‚                    â”‚                      â”‚                        â”‚
â”‚ Appel              â”‚ test();              â”‚ $objet->test();        â”‚
â”‚                    â”‚                      â”‚                        â”‚
â”‚ AccÃ¨s aux          â”‚ Non (sauf si passÃ©es â”‚ Oui (via $this)        â”‚
â”‚ propriÃ©tÃ©s         â”‚ en paramÃ¨tre)        â”‚                        â”‚
â”‚                    â”‚                      â”‚                        â”‚
â”‚ Modificateur       â”‚ Aucun                â”‚ public, private,       â”‚
â”‚                    â”‚                      â”‚ protected              â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


EXEMPLE 4 : MÃ‰THODE UTILISANT LES PROPRIÃ‰TÃ‰S
---------------------------------------------

<?php
class CompteBancaire {
    public $solde = 0;

    public function deposer($montant) {
        $this->solde = $this->solde + $montant;
        echo "DÃ©pÃ´t de $montantâ‚¬. Nouveau solde : $this->soldeâ‚¬\n";
    }

    public function retirer($montant) {
        $this->solde = $this->solde - $montant;
        echo "Retrait de $montantâ‚¬. Nouveau solde : $this->soldeâ‚¬\n";
    }

    public function afficherSolde() {
        echo "Solde actuel : $this->soldeâ‚¬\n";
    }
}

$compte = new CompteBancaire();
$compte->afficherSolde();   // Solde actuel : 0â‚¬
$compte->deposer(100);      // DÃ©pÃ´t de 100â‚¬. Nouveau solde : 100â‚¬
$compte->retirer(30);       // Retrait de 30â‚¬. Nouveau solde : 70â‚¬
$compte->afficherSolde();   // Solde actuel : 70â‚¬
?>


ERREURS COURANTES :
-------------------

// âŒ ERREUR : Oublier les parenthÃ¨ses
$chien->aboyer;  // Ne fait rien, accÃ¨de Ã  une propriÃ©tÃ© inexistante

// âŒ ERREUR : Appeler une mÃ©thode qui n'existe pas
$chien->miauler();  // Fatal error: Call to undefined method

// âŒ ERREUR : Confondre fonction et mÃ©thode
class Test {
    function maMethode() {}  // âŒ Manque le modificateur public
}

// âœ… CORRECT :
class Test {
    public function maMethode() {}  // âœ… Avec modificateur
}


ğŸ’¡ BONNE PRATIQUE :
Toujours utiliser le modificateur public (ou private/protected) devant vos
mÃ©thodes, mÃªme si PHP l'accepte sans.


================================================================================
F. MODIFICATEURS D'ACCÃˆS (public, private, protected)
================================================================================

â­ SECTION IMPORTANTE : C'est ici que nous rÃ©pondons Ã  votre question !


F.1 - INTRODUCTION AUX MODIFICATEURS D'ACCÃˆS
---------------------------------------------

QU'EST-CE QU'UN MODIFICATEUR D'ACCÃˆS ?
Les modificateurs d'accÃ¨s contrÃ´lent QUI peut accÃ©der aux propriÃ©tÃ©s et
mÃ©thodes d'une classe.

LES 3 NIVEAUX D'ACCÃˆS :
1. public    : Accessible PARTOUT (de l'intÃ©rieur, de l'extÃ©rieur, des enfants)
2. private   : Accessible UNIQUEMENT dans la classe oÃ¹ c'est dÃ©fini
3. protected : Accessible dans la classe ET dans les classes enfants (hÃ©ritage)

âš ï¸ NOTE IMPORTANTE :
Si vous ne spÃ©cifiez aucun modificateur, PHP utilise "public" par dÃ©faut.
CEPENDANT, il est fortement recommandÃ© de TOUJOURS spÃ©cifier explicitement le
modificateur (public, private ou protected) pour rendre votre code clair et
professionnel.


POURQUOI C'EST IMPORTANT ?
---------------------------
âœ“ SÃ‰CURITÃ‰ : ProtÃ©ger les donnÃ©es sensibles
âœ“ ENCAPSULATION : Cacher les dÃ©tails d'implÃ©mentation
âœ“ CONTRÃ”LE : Forcer l'utilisation de mÃ©thodes pour valider les donnÃ©es
âœ“ MAINTENANCE : Modifier l'interne sans casser le code externe


F.2 - PUBLIC : ACCESSIBLE PARTOUT
----------------------------------

DÃ‰FINITION :
Une propriÃ©tÃ© ou mÃ©thode "public" est accessible :
- âœ… De l'intÃ©rieur de la classe
- âœ… De l'extÃ©rieur de la classe (via $objet->)
- âœ… Depuis les classes enfants (hÃ©ritage)

SYNTAXE :
    public $propriete;
    public function methode() {}


EXEMPLE :

<?php
class Personne {
    public $nom = "Alice";        // âœ… PropriÃ©tÃ© publique
    public $prenom = "Dupont";    // âœ… PropriÃ©tÃ© publique

    public function sePresenter() {  // âœ… MÃ©thode publique
        echo "Je m'appelle $this->nom $this->prenom\n";
    }
}

// Utilisation
$personne = new Personne();

// âœ… AccÃ¨s DIRECT depuis l'extÃ©rieur (fonctionne)
echo $personne->nom;  // Alice
$personne->nom = "Bob";  // Modifier directement

// âœ… Appel de mÃ©thode publique (fonctionne)
$personne->sePresenter();  // Je m'appelle Bob Dupont
?>


QUAND UTILISER "public" ?
--------------------------
â€¢ Pour les mÃ©thodes que vous voulez rendre accessibles de l'extÃ©rieur
â€¢ Pour les propriÃ©tÃ©s simples sans validation nÃ©cessaire
â€¢ Par dÃ©faut, si vous n'avez pas besoin de protection


âš ï¸ ATTENTION :
Utiliser "public" pour toutes les propriÃ©tÃ©s peut Ãªtre dangereux ! Quelqu'un
peut modifier vos donnÃ©es sans validation. C'est lÃ  que "private" intervient.


F.3 - PRIVATE : UNIQUEMENT DANS LA CLASSE
------------------------------------------

DÃ‰FINITION :
Une propriÃ©tÃ© ou mÃ©thode "private" est accessible :
- âœ… Uniquement de l'intÃ©rieur de la classe
- âŒ PAS de l'extÃ©rieur de la classe
- âŒ PAS depuis les classes enfants

SYNTAXE :
    private $propriete;
    private function methode() {}


EXEMPLE : COMPTE BANCAIRE (Protection du solde)

<?php
class CompteBancaire {
    private $solde = 0;  // âŒ Pas accessible de l'extÃ©rieur = PROTECTION

    // âœ… MÃ©thodes publiques pour accÃ©der au solde de maniÃ¨re contrÃ´lÃ©e
    public function deposer($montant) {
        if ($montant > 0) {  // âœ… Validation
            $this->solde += $montant;
            echo "DÃ©pÃ´t de $montantâ‚¬ effectuÃ©.\n";
        } else {
            echo "âŒ Montant invalide.\n";
        }
    }

    public function retirer($montant) {
        if ($montant > 0 && $montant <= $this->solde) {  // âœ… Validation
            $this->solde -= $montant;
            echo "Retrait de $montantâ‚¬ effectuÃ©.\n";
        } else {
            echo "âŒ Retrait impossible (solde insuffisant ou montant invalide).\n";
        }
    }

    public function getSolde() {  // âœ… Getter (lecture seulement)
        return $this->solde;
    }
}

// Utilisation
$compte = new CompteBancaire();

// âŒ ERREUR : Impossible d'accÃ©der directement Ã  $solde
// echo $compte->solde;
// Fatal error: Cannot access private property CompteBancaire::$solde

// âŒ ERREUR : Impossible de modifier directement
// $compte->solde = 1000000;
// Fatal error: Cannot access private property

// âœ… CORRECT : Utiliser les mÃ©thodes publiques
$compte->deposer(500);     // DÃ©pÃ´t de 500â‚¬
$compte->retirer(200);     // Retrait de 200â‚¬
echo $compte->getSolde();  // 300 (accÃ¨s via getter)

// âœ… La validation fonctionne :
$compte->retirer(5000);    // âŒ Retrait impossible (solde insuffisant)
?>


PRINCIPE D'ENCAPSULATION :
--------------------------
L'encapsulation consiste Ã  :
1. Rendre les propriÃ©tÃ©s PRIVATE (protÃ©ger)
2. CrÃ©er des mÃ©thodes PUBLIC pour y accÃ©der (contrÃ´ler)

Avantages :
â€¢ EmpÃªche les modifications non autorisÃ©es
â€¢ Permet de valider les donnÃ©es avant de les stocker
â€¢ Permet de changer l'implÃ©mentation interne sans casser le code externe


GETTERS ET SETTERS :
--------------------
Conventions pour accÃ©der aux propriÃ©tÃ©s privÃ©es :

<?php
class Utilisateur {
    private $age;

    // GETTER : Obtenir la valeur (lecture)
    public function getAge() {
        return $this->age;
    }

    // SETTER : DÃ©finir la valeur (Ã©criture avec validation)
    public function setAge($nouvelAge) {
        if ($nouvelAge >= 0 && $nouvelAge <= 150) {  // âœ… Validation
            $this->age = $nouvelAge;
        } else {
            echo "âŒ Ã‚ge invalide.\n";
        }
    }
}

$user = new Utilisateur();
$user->setAge(25);        // âœ… Passe la validation
echo $user->getAge();     // 25

$user->setAge(-5);        // âŒ Ã‚ge invalide
$user->setAge(200);       // âŒ Ã‚ge invalide
?>


MÃ‰THODES PRIVÃ‰ES :
------------------
Les mÃ©thodes peuvent aussi Ãªtre privÃ©es (utilisÃ©es en interne seulement) :

<?php
class Robot {
    private function demarrerMoteur() {  // âœ… MÃ©thode privÃ©e
        echo "Moteur dÃ©marrÃ© (interne)\n";
    }

    public function activer() {  // âœ… MÃ©thode publique
        echo "Activation du robot...\n";
        $this->demarrerMoteur();  // âœ… Appel interne OK
        echo "Robot activÃ© !\n";
    }
}

$robot = new Robot();
$robot->activer();  // âœ… Fonctionne
// Affiche :
// Activation du robot...
// Moteur dÃ©marrÃ© (interne)
// Robot activÃ© !

// âŒ ERREUR : Impossible d'appeler la mÃ©thode privÃ©e
// $robot->demarrerMoteur();
// Fatal error: Call to private method Robot::demarrerMoteur()
?>


QUAND UTILISER "private" ?
---------------------------
â€¢ Pour les propriÃ©tÃ©s contenant des donnÃ©es sensibles (mot de passe, solde...)
â€¢ Pour les propriÃ©tÃ©s nÃ©cessitant une validation avant modification
â€¢ Pour les mÃ©thodes internes (helpers) utilisÃ©es uniquement dans la classe
â€¢ Par dÃ©faut, protÃ©gez tout avec "private" et rendez "public" si nÃ©cessaire


F.4 - PROTECTED : CLASSE ET ENFANTS
------------------------------------

DÃ‰FINITION :
Une propriÃ©tÃ© ou mÃ©thode "protected" est accessible :
- âœ… De l'intÃ©rieur de la classe
- âœ… Depuis les classes enfants (via hÃ©ritage)
- âŒ PAS de l'extÃ©rieur de la classe

SYNTAXE :
    protected $propriete;
    protected function methode() {}


EXEMPLE : HÃ‰RITAGE AVEC PROTECTED

<?php
// Classe PARENT
class Animal {
    protected $energie = 100;  // âœ… Protected (accessible aux enfants)

    public function afficherEnergie() {
        echo "Ã‰nergie : $this->energie\n";
    }
}

// Classe ENFANT (hÃ©rite de Animal)
class Chien extends Animal {
    public function courir() {
        // âœ… ACCÃˆS POSSIBLE : protected est accessible dans la classe enfant
        $this->energie -= 10;
        echo "Le chien court ! ";
        $this->afficherEnergie();
    }

    public function manger() {
        // âœ… ACCÃˆS POSSIBLE
        $this->energie += 20;
        echo "Le chien mange ! ";
        $this->afficherEnergie();
    }
}

// Utilisation
$chien = new Chien();
$chien->afficherEnergie();  // Ã‰nergie : 100

$chien->courir();  // Le chien court ! Ã‰nergie : 90
$chien->manger();  // Le chien mange ! Ã‰nergie : 110

// âŒ ERREUR : Impossible d'accÃ©der directement de l'extÃ©rieur
// echo $chien->energie;
// Fatal error: Cannot access protected property Chien::$energie
?>


COMPARAISON : PRIVATE vs PROTECTED
-----------------------------------

<?php
class Parent {
    private $secret = "privÃ©";       // âŒ Enfants n'y ont PAS accÃ¨s
    protected $partage = "protÃ©gÃ©";  // âœ… Enfants y ont accÃ¨s
}

class Enfant extends Parent {
    public function tester() {
        // âŒ ERREUR : private n'est pas accessible
        // echo $this->secret;
        // Fatal error: Cannot access private property

        // âœ… OK : protected est accessible
        echo $this->partage;  // Fonctionne
    }
}
?>


QUAND UTILISER "protected" ?
-----------------------------
â€¢ Quand vous voulez partager des propriÃ©tÃ©s/mÃ©thodes avec les classes enfants
â€¢ Pour crÃ©er une "API interne" pour vos classes dÃ©rivÃ©es
â€¢ Quand vous prÃ©voyez que votre classe sera Ã©tendue (hÃ©ritage)
â€¢ Pour les mÃ©thodes "helper" utilisÃ©es par la classe et ses enfants


F.5 - TABLEAU COMPARATIF VISUEL
--------------------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Modificateur â”‚ Dans la classe     â”‚ Classes enfants    â”‚ Dehors          â”‚
â”‚              â”‚ elle-mÃªme          â”‚ (extends)          â”‚ (partout)       â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ public       â”‚ âœ… OUI             â”‚ âœ… OUI             â”‚ âœ… OUI          â”‚
â”‚              â”‚                    â”‚                    â”‚                 â”‚
â”‚ protected    â”‚ âœ… OUI             â”‚ âœ… OUI             â”‚ âŒ NON          â”‚
â”‚              â”‚                    â”‚                    â”‚                 â”‚
â”‚ private      â”‚ âœ… OUI             â”‚ âŒ NON             â”‚ âŒ NON          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


F.6 - SCHÃ‰MA DES ZONES D'ACCÃˆS
-------------------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  DEHORS (reste du code)                             â”‚
â”‚                                                                     â”‚
â”‚  public = âœ… Accessible ici                                         â”‚
â”‚  protected = âŒ Pas accessible                                      â”‚
â”‚  private = âŒ Pas accessible                                        â”‚
â”‚                                                                     â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚        CLASSE ENFANT (extends Parent)                      â”‚    â”‚
â”‚  â”‚                                                            â”‚    â”‚
â”‚  â”‚  public = âœ… Accessible ici                                â”‚    â”‚
â”‚  â”‚  protected = âœ… Accessible ici (hÃ©ritÃ© du parent)          â”‚    â”‚
â”‚  â”‚  private = âŒ Pas accessible (reste dans le parent)        â”‚    â”‚
â”‚  â”‚                                                            â”‚    â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚    â”‚
â”‚  â”‚  â”‚     CLASSE PARENT (classe de base)                   â”‚ â”‚    â”‚
â”‚  â”‚  â”‚                                                      â”‚ â”‚    â”‚
â”‚  â”‚  â”‚  public $x      â† Accessible PARTOUT               â”‚ â”‚    â”‚
â”‚  â”‚  â”‚  protected $y   â† Accessible ICI + enfants          â”‚ â”‚    â”‚
â”‚  â”‚  â”‚  private $z     â† Accessible UNIQUEMENT ICI         â”‚ â”‚    â”‚
â”‚  â”‚  â”‚                                                      â”‚ â”‚    â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


ANALOGIE DU MONDE RÃ‰EL :
------------------------
Pensez Ã  des informations personnelles :

class Personne {
    public $nom = "Alice";               // âœ… Nom : visible par TOUT LE MONDE
    protected $adresse = "123 rue";      // âš ï¸ Adresse : famille uniquement
    private $motDePasse = "secret123";   // ğŸ”’ Mot de passe : VOUS SEUL
}

â€¢ Tout le monde peut connaÃ®tre votre NOM (public)
â€¢ Votre famille peut connaÃ®tre votre ADRESSE (protected)
â€¢ PERSONNE ne doit connaÃ®tre votre MOT DE PASSE sauf vous (private)


RÃ‰CAPITULATIF : QUEL MODIFICATEUR CHOISIR ?
--------------------------------------------

RÃˆGLE D'OR : "Principe du moindre privilÃ¨ge"
Commencez toujours par "private" et rendez "public" seulement si nÃ©cessaire.

1. Utilisez "private" PAR DÃ‰FAUT pour :
   - PropriÃ©tÃ©s contenant des donnÃ©es sensibles
   - MÃ©thodes internes (helpers)

2. Utilisez "protected" si :
   - Vous prÃ©voyez que la classe sera Ã©tendue (hÃ©ritage)
   - Vous voulez partager avec les classes enfants

3. Utilisez "public" seulement pour :
   - MÃ©thodes formant l'interface publique de votre classe
   - PropriÃ©tÃ©s simples sans besoin de validation (rare)


EXEMPLE COMPLET - MISE EN PRATIQUE :
-------------------------------------

<?php
class Voiture {
    // PropriÃ©tÃ©s PRIVATE (protection)
    private $vitesse = 0;
    private $moteurDemarre = false;

    // MÃ©thodes PUBLIC (interface)
    public function demarrer() {
        if (!$this->moteurDemarre) {
            $this->moteurDemarre = true;
            echo "Moteur dÃ©marrÃ©.\n";
        } else {
            echo "Le moteur est dÃ©jÃ  dÃ©marrÃ©.\n";
        }
    }

    public function accelerer($augmentation) {
        if ($this->moteurDemarre) {
            $this->vitesse += $augmentation;
            echo "Vitesse : $this->vitesse km/h\n";
        } else {
            echo "âŒ DÃ©marrez le moteur d'abord !\n";
        }
    }

    public function freiner($diminution) {
        $this->vitesse -= $diminution;
        if ($this->vitesse < 0) {
            $this->vitesse = 0;
        }
        echo "Vitesse : $this->vitesse km/h\n";
    }

    public function afficherVitesse() {
        echo "Vitesse actuelle : $this->vitesse km/h\n";
    }
}

// Utilisation
$voiture = new Voiture();

// âŒ Impossible de tricher sur la vitesse :
// $voiture->vitesse = 300;  // Fatal error

// âœ… Utiliser l'interface publique (mÃ©thodes) :
$voiture->accelerer(50);   // âŒ DÃ©marrez le moteur d'abord !
$voiture->demarrer();      // Moteur dÃ©marrÃ©
$voiture->accelerer(50);   // Vitesse : 50 km/h
$voiture->accelerer(30);   // Vitesse : 80 km/h
$voiture->freiner(20);     // Vitesse : 60 km/h
?>

GrÃ¢ce Ã  "private", on FORCE l'utilisateur Ã  passer par nos mÃ©thodes, ce qui
garantit que les rÃ¨gles sont respectÃ©es (impossible d'accÃ©lÃ©rer sans dÃ©marrer).


================================================================================
G. LE CONSTRUCTEUR - INITIALISER UN OBJET
================================================================================

QU'EST-CE QU'UN CONSTRUCTEUR ?
-------------------------------
Le constructeur est une mÃ©thode spÃ©ciale qui est appelÃ©e AUTOMATIQUEMENT
lorsque vous crÃ©ez un nouvel objet avec "new".

Il sert Ã  INITIALISER les propriÃ©tÃ©s de l'objet.

SYNTAXE :
    public function __construct($param1, $param2) {
        // Code d'initialisation
    }

âš ï¸ ATTENTION : Le nom de la mÃ©thode est "__construct" avec DEUX underscores.


POURQUOI UTILISER UN CONSTRUCTEUR ?
------------------------------------
SANS constructeur, vous devez assigner les propriÃ©tÃ©s manuellement (fastidieux) :

<?php
// âŒ FASTIDIEUX (sans constructeur)
class Personne {
    public $nom;
    public $age;
}

$p1 = new Personne();
$p1->nom = "Alice";
$p1->age = 25;

$p2 = new Personne();
$p2->nom = "Bob";
$p2->age = 30;
?>


AVEC constructeur, tout se fait en UNE LIGNE (Ã©lÃ©gant) :

<?php
// âœ… Ã‰LÃ‰GANT (avec constructeur)
class Personne {
    public $nom;
    public $age;

    public function __construct($nom, $age) {
        $this->nom = $nom;
        $this->age = $age;
    }
}

// Tout en une ligne !
$p1 = new Personne("Alice", 25);
$p2 = new Personne("Bob", 30);

echo $p1->nom;  // Alice
echo $p2->age;  // 30
?>


TABLEAU COMPARATIF :
--------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       â”‚ Sans constructeur    â”‚ Avec constructeur      â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ Lignes de code        â”‚ 4 lignes par objet   â”‚ 1 ligne par objet      â”‚
â”‚                       â”‚                      â”‚                        â”‚
â”‚ Risque d'oubli        â”‚ Ã‰levÃ© (oublier une   â”‚ Aucun (tout en une     â”‚
â”‚                       â”‚ propriÃ©tÃ©)           â”‚ fois)                  â”‚
â”‚                       â”‚                      â”‚                        â”‚
â”‚ LisibilitÃ©            â”‚ Moyenne              â”‚ Excellente             â”‚
â”‚                       â”‚                      â”‚                        â”‚
â”‚ Validation possible   â”‚ Non                  â”‚ Oui (dans le           â”‚
â”‚                       â”‚                      â”‚ constructeur)          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


EXEMPLE AVEC VALIDATION :
--------------------------

<?php
class Utilisateur {
    private $age;
    private $email;

    public function __construct($age, $email) {
        // âœ… Validation dans le constructeur
        if ($age < 0) {
            $age = 0;  // Correction automatique
        }

        $this->age = $age;
        $this->email = $email;
    }

    public function getAge() {
        return $this->age;
    }
}

$user = new Utilisateur(-5, "test@example.com");
echo $user->getAge();  // 0 (corrigÃ© automatiquement)
?>


CONSTRUCTEUR AVEC VALEURS PAR DÃ‰FAUT :
---------------------------------------

<?php
class Produit {
    private $nom;
    private $prix;
    private $enStock;

    // ParamÃ¨tre avec valeur par dÃ©faut
    public function __construct($nom, $prix, $enStock = true) {
        $this->nom = $nom;
        $this->prix = $prix;
        $this->enStock = $enStock;
    }
}

// Avec 3 arguments
$p1 = new Produit("Laptop", 1000, false);

// Avec 2 arguments (enStock = true par dÃ©faut)
$p2 = new Produit("Souris", 25);
?>


EXEMPLE PRATIQUE : LIVRE
-------------------------

<?php
class Livre {
    private $titre;
    private $auteur;
    private $annee;

    public function __construct($titre, $auteur, $annee) {
        $this->titre = $titre;
        $this->auteur = $auteur;
        $this->annee = $annee;
    }

    public function afficherInfos() {
        echo "$this->titre par $this->auteur ($this->annee)\n";
    }
}

// CrÃ©er plusieurs livres facilement
$livre1 = new Livre("1984", "George Orwell", 1949);
$livre2 = new Livre("Le Petit Prince", "Saint-ExupÃ©ry", 1943);
$livre3 = new Livre("Harry Potter", "J.K. Rowling", 1997);

$livre1->afficherInfos();  // 1984 par George Orwell (1949)
$livre2->afficherInfos();  // Le Petit Prince par Saint-ExupÃ©ry (1943)
?>


ERREURS COURANTES :
-------------------

// âŒ ERREUR : Faute dans le nom
class Test {
    public function construct() {}  // âŒ Manque les deux underscores
}

// âŒ ERREUR : Mauvais nombre d'arguments
class Personne {
    public function __construct($nom, $age) {}
}
$p = new Personne("Alice");  // Fatal error: Too few arguments

// âœ… CORRECT :
class Personne {
    public function __construct($nom, $age) {
        $this->nom = $nom;
        $this->age = $age;
    }
}


ğŸ’¡ BONNE PRATIQUE :
Utilisez TOUJOURS un constructeur si votre classe a des propriÃ©tÃ©s qui doivent
Ãªtre initialisÃ©es. Cela rend votre code plus propre et Ã©vite les oublis.


================================================================================
H. $this - RÃ‰FÃ‰RENCER L'OBJET ACTUEL
================================================================================

QU'EST-CE QUE $this ?
---------------------
$this est un mot-clÃ© spÃ©cial qui reprÃ©sente "L'OBJET ACTUEL".

Ã€ l'intÃ©rieur d'une mÃ©thode, $this fait rÃ©fÃ©rence Ã  l'objet qui a appelÃ©
cette mÃ©thode.

Pensez Ã  $this comme "MOI-MÃŠME" ou "CET OBJET-CI".


SYNTAXE :
---------
    $this->propriete     // AccÃ©der Ã  une propriÃ©tÃ©
    $this->methode()     // Appeler une mÃ©thode


EXEMPLE 1 : COMPRENDRE $this
-----------------------------

<?php
class Compteur {
    public $valeur = 0;

    public function incrementer() {
        $this->valeur++;  // $this = cet objet-ci
        //   â†‘
        // "dans MOI-MÃŠME, incrÃ©menter ma propriÃ©tÃ© valeur"
    }

    public function afficher() {
        echo "Valeur : $this->valeur\n";
    }
}

$c1 = new Compteur();
$c1->incrementer();  // Ici, $this = $c1
$c1->afficher();     // Valeur : 1

$c2 = new Compteur();
$c2->incrementer();  // Ici, $this = $c2 (diffÃ©rent de $c1 !)
$c2->incrementer();
$c2->afficher();     // Valeur : 2

// Les deux compteurs sont indÃ©pendants
$c1->afficher();     // Valeur : 1 (inchangÃ©)
?>


SCHÃ‰MA VISUEL :
---------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  Objet $c1                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚ $valeur = 1                    â”‚ â”‚
â”‚  â”‚                                â”‚ â”‚
â”‚  â”‚ incrementer() {                â”‚ â”‚
â”‚  â”‚   $this->valeur++              â”‚ â”‚
â”‚  â”‚     â†‘                          â”‚ â”‚
â”‚  â”‚     â””â”€ Fait rÃ©fÃ©rence Ã         â”‚ â”‚
â”‚  â”‚        la propriÃ©tÃ© de CE $c1  â”‚ â”‚
â”‚  â”‚ }                              â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


EXEMPLE 2 : DIFFÃ‰RENCE ENTRE $this-> et $
------------------------------------------

<?php
class User {
    public $nom = "Alice";

    public function afficher() {
        // âŒ ERREUR : $nom n'existe pas dans cette portÃ©e
        // echo $nom;  // Warning: Undefined variable $nom

        // âœ… CORRECT : AccÃ©der Ã  la propriÃ©tÃ© de l'objet
        echo $this->nom;  // Alice
    }

    public function tester($nom) {  // ParamÃ¨tre local
        echo $nom;         // Affiche le PARAMÃˆTRE
        echo $this->nom;   // Affiche la PROPRIÃ‰TÃ‰ de l'objet
    }
}

$user = new User();
$user->afficher();    // Alice
$user->tester("Bob"); // Bob (paramÃ¨tre) puis Alice (propriÃ©tÃ©)
?>


EXEMPLE 3 : APPELER UNE MÃ‰THODE DEPUIS UNE AUTRE
-------------------------------------------------

<?php
class Robot {
    private $batterie = 100;

    private function verifierBatterie() {
        if ($this->batterie < 20) {
            echo "âš ï¸ Batterie faible !\n";
        }
    }

    public function travailler() {
        echo "Le robot travaille...\n";
        $this->batterie -= 10;

        // âœ… Appeler une autre mÃ©thode de l'objet
        $this->verifierBatterie();
    }

    public function recharger() {
        echo "Recharge en cours...\n";
        $this->batterie = 100;
    }
}

$robot = new Robot();
$robot->travailler();  // Le robot travaille...
$robot->travailler();  // Le robot travaille... âš ï¸ Batterie faible !
?>


EXEMPLE 4 : CHAÃNAGE DE MÃ‰THODES
---------------------------------

Vous pouvez retourner $this pour permettre le chaÃ®nage :

<?php
class Texte {
    private $contenu = "";

    public function ajouter($texte) {
        $this->contenu .= $texte;
        return $this;  // âœ… Retourner l'objet lui-mÃªme
    }

    public function afficher() {
        echo $this->contenu . "\n";
        return $this;
    }
}

$texte = new Texte();

// âœ… ChaÃ®nage de mÃ©thodes (mÃ©thode fluente)
$texte->ajouter("Bonjour ")
      ->ajouter("le ")
      ->ajouter("monde !")
      ->afficher();  // Bonjour le monde !
?>


ERREURS COURANTES :
-------------------

// âŒ ERREUR : Oublier $this->
class User {
    public $nom = "Alice";

    public function afficher() {
        echo $nom;  // âŒ Undefined variable $nom
    }
}

// âŒ ERREUR : Utiliser $this hors d'une classe
$this->nom = "Test";  // âŒ Fatal error: Using $this when not in object context

// âŒ ERREUR : Confondre propriÃ©tÃ© et variable locale
class Test {
    public $valeur = 10;

    public function calculer() {
        $valeur = 5;  // Variable locale (n'affecte PAS $this->valeur)
        echo $this->valeur;  // 10 (propriÃ©tÃ© inchangÃ©e)
    }
}

// âœ… CORRECT : Toujours utiliser $this-> pour les propriÃ©tÃ©s
class Test {
    public $valeur = 10;

    public function calculer() {
        $this->valeur = 5;  // âœ… Modifie la propriÃ©tÃ©
        echo $this->valeur;  // 5
    }
}


POINT CLÃ‰ :
-----------
Pensez Ã  $this comme Ã  dire "MON propre..." ou "MA propre..." en franÃ§ais :

$this->nom         â†’  "MON nom"
$this->calculer()  â†’  "MA mÃ©thode calculer()"


================================================================================
I. L'HÃ‰RITAGE - RÃ‰UTILISER DU CODE
================================================================================

QU'EST-CE QUE L'HÃ‰RITAGE ?
---------------------------
L'hÃ©ritage permet Ã  une classe (ENFANT) de rÃ©utiliser les propriÃ©tÃ©s et
mÃ©thodes d'une autre classe (PARENT).

C'est comme dire : "Un Chien EST UN Animal" â†’ le Chien hÃ©rite des
caractÃ©ristiques d'Animal.

SYNTAXE :
    class ClasseEnfant extends ClasseParent {
        // Code supplÃ©mentaire
    }

MOT-CLÃ‰ : "extends"


EXEMPLE 1 : HÃ‰RITAGE DE BASE
-----------------------------

<?php
// Classe PARENT (classe de base)
class Animal {
    public $nom;
    public $age;

    public function manger() {
        echo "$this->nom mange.\n";
    }

    public function dormir() {
        echo "$this->nom dort.\n";
    }
}

// Classe ENFANT (hÃ©rite de Animal)
class Chien extends Animal {
    public function aboyer() {
        echo "$this->nom dit : Woof!\n";
    }
}

// Utilisation
$chien = new Chien();
$chien->nom = "Rex";

// âœ… MÃ©thodes hÃ©ritÃ©es du parent (Animal)
$chien->manger();   // Rex mange.
$chien->dormir();   // Rex dort.

// âœ… MÃ©thode propre au Chien
$chien->aboyer();   // Rex dit : Woof!
?>


HIÃ‰RARCHIE VISUELLE :
---------------------

        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚      Animal         â”‚  â† Classe PARENT (base)
        â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚
        â”‚  + $nom             â”‚
        â”‚  + $age             â”‚
        â”‚  + manger()         â”‚
        â”‚  + dormir()         â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                   â”‚ extends
                   â”‚
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚       Chien         â”‚  â† Classe ENFANT
        â”‚  â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€    â”‚     (hÃ©rite TOUT de Animal)
        â”‚  + aboyer()         â”‚     + ajoute ses propres mÃ©thodes
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


EXEMPLE 2 : PLUSIEURS CLASSES ENFANTS
--------------------------------------

<?php
class Animal {
    public $nom;

    public function manger() {
        echo "$this->nom mange.\n";
    }
}

// Premier enfant
class Chien extends Animal {
    public function aboyer() {
        echo "Woof!\n";
    }
}

// DeuxiÃ¨me enfant
class Chat extends Animal {
    public function miauler() {
        echo "Miaou!\n";
    }
}

// TroisiÃ¨me enfant
class Oiseau extends Animal {
    public function voler() {
        echo "$this->nom vole.\n";
    }
}

// Utilisation
$chien = new Chien();
$chien->nom = "Rex";
$chien->manger();  // âœ… HÃ©ritÃ©
$chien->aboyer();  // âœ… Propre

$chat = new Chat();
$chat->nom = "Mimi";
$chat->manger();   // âœ… HÃ©ritÃ©
$chat->miauler();  // âœ… Propre
?>


SURCHARGE DE MÃ‰THODE (Override) :
----------------------------------
Une classe enfant peut REDÃ‰FINIR (override) une mÃ©thode hÃ©ritÃ©e :

<?php
class Animal {
    public function sePresenter() {
        echo "Je suis un animal.\n";
    }
}

class Chat extends Animal {
    // âœ… RedÃ©finir (override) la mÃ©thode du parent
    public function sePresenter() {
        echo "Je suis un chat (miaou!).\n";
    }
}

class Chien extends Animal {
    public function sePresenter() {
        echo "Je suis un chien (woof!).\n";
    }
}

$animal = new Animal();
$animal->sePresenter();  // Je suis un animal.

$chat = new Chat();
$chat->sePresenter();    // Je suis un chat (miaou!).

$chien = new Chien();
$chien->sePresenter();   // Je suis un chien (woof!).
?>


APPELER LA MÃ‰THODE PARENT AVEC parent::
----------------------------------------

Si vous voulez utiliser la mÃ©thode du parent ET ajouter du code :

<?php
class Animal {
    public function sePresenter() {
        echo "Je suis un animal.\n";
    }
}

class Chien extends Animal {
    public function sePresenter() {
        parent::sePresenter();  // âœ… Appeler la version du parent
        echo "Plus prÃ©cisÃ©ment, un chien.\n";
    }
}

$chien = new Chien();
$chien->sePresenter();
// Affiche :
// Je suis un animal.
// Plus prÃ©cisÃ©ment, un chien.
?>


HÃ‰RITAGE ET PROTECTED (Rappel) :
---------------------------------

<?php
class Animal {
    protected $energie = 100;  // âœ… Accessible dans les enfants

    public function afficherEnergie() {
        echo "Ã‰nergie : $this->energie\n";
    }
}

class Chien extends Animal {
    public function courir() {
        // âœ… AccÃ¨s possible car protected
        $this->energie -= 10;
        echo "Le chien court !\n";
    }
}

$chien = new Chien();
$chien->afficherEnergie();  // Ã‰nergie : 100
$chien->courir();           // Le chien court !
$chien->afficherEnergie();  // Ã‰nergie : 90

// âŒ Impossible de l'extÃ©rieur (protected)
// echo $chien->energie;  // Fatal error
?>


CONSTRUCTEUR ET HÃ‰RITAGE :
--------------------------

<?php
class Animal {
    protected $nom;

    public function __construct($nom) {
        $this->nom = $nom;
        echo "Animal crÃ©Ã© : $nom\n";
    }
}

class Chien extends Animal {
    private $race;

    public function __construct($nom, $race) {
        parent::__construct($nom);  // âœ… Appeler le constructeur parent
        $this->race = $race;
        echo "Chien de race : $race\n";
    }
}

$chien = new Chien("Rex", "Berger Allemand");
// Affiche :
// Animal crÃ©Ã© : Rex
// Chien de race : Berger Allemand
?>


RELATION "EST UN" (is-a) :
--------------------------
L'hÃ©ritage reprÃ©sente une relation "EST UN" :

âœ… Un Chien EST UN Animal       â†’ HÃ©ritage logique
âœ… Une Voiture EST UN VÃ©hicule  â†’ HÃ©ritage logique
âœ… Un CarrÃ© EST UN Rectangle    â†’ HÃ©ritage logique

âŒ Un Chien A UNE Queue         â†’ Pas d'hÃ©ritage (composition)
âŒ Une Voiture A UN Moteur      â†’ Pas d'hÃ©ritage (composition)


EXEMPLE PRATIQUE : VÃ‰HICULES
-----------------------------

<?php
class Vehicule {
    protected $marque;
    protected $vitesse = 0;

    public function __construct($marque) {
        $this->marque = $marque;
    }

    public function accelerer($augmentation) {
        $this->vitesse += $augmentation;
        echo "$this->marque accÃ©lÃ¨re Ã  $this->vitesse km/h\n";
    }
}

class Voiture extends Vehicule {
    private $nombrePortes;

    public function __construct($marque, $nombrePortes) {
        parent::__construct($marque);
        $this->nombrePortes = $nombrePortes;
    }

    public function klaxonner() {
        echo "Beep beep !\n";
    }
}

class Moto extends Vehicule {
    public function faireCavalier() {
        echo "Vroooom !\n";
    }
}

$voiture = new Voiture("Toyota", 4);
$voiture->accelerer(50);  // Toyota accÃ©lÃ¨re Ã  50 km/h
$voiture->klaxonner();    // Beep beep !

$moto = new Moto("Harley");
$moto->accelerer(80);     // Harley accÃ©lÃ¨re Ã  80 km/h
$moto->faireCavalier();   // Vroooom !
?>


LIMITES DE L'HÃ‰RITAGE :
-----------------------
â€¢ PHP ne supporte que l'hÃ©ritage SIMPLE (un seul parent direct)
â€¢ âŒ class Chien extends Animal, Mammifere  // Impossible en PHP
â€¢ âœ… Utiliser les interfaces pour l'hÃ©ritage multiple (sujet avancÃ©)


QUAND UTILISER L'HÃ‰RITAGE ?
----------------------------
âœ“ Quand il y a une relation "EST UN"
âœ“ Pour rÃ©utiliser du code commun
âœ“ Pour crÃ©er des hiÃ©rarchies logiques (Animal â†’ Chien, Chat, Oiseau)
âœ“ Quand les classes partagent des comportements similaires


================================================================================
J. EXEMPLE PRATIQUE COMPLET - SYSTÃˆME DE BIBLIOTHÃˆQUE
================================================================================

CET EXEMPLE INTÃˆGRE TOUS LES CONCEPTS VUS :
âœ“ Classe et objet
âœ“ PropriÃ©tÃ©s private (encapsulation)
âœ“ MÃ©thodes public
âœ“ Constructeur
âœ“ $this
âœ“ Validation dans les mÃ©thodes
âœ“ Getters


CODE COMPLET :
--------------

<?php
class Livre {
    // PropriÃ©tÃ©s PRIVATE (protection)
    private $titre;
    private $auteur;
    private $annee;
    private $disponible = true;  // Par dÃ©faut, le livre est disponible

    // Constructeur : initialiser le livre
    public function __construct($titre, $auteur, $annee) {
        $this->titre = $titre;
        $this->auteur = $auteur;
        $this->annee = $annee;
    }

    // MÃ©thode pour emprunter le livre
    public function emprunter() {
        if ($this->disponible) {
            $this->disponible = false;
            echo "âœ… Livre '$this->titre' empruntÃ© avec succÃ¨s.\n";
            return true;
        } else {
            echo "âŒ DÃ©solÃ©, '$this->titre' est dÃ©jÃ  empruntÃ©.\n";
            return false;
        }
    }

    // MÃ©thode pour retourner le livre
    public function retourner() {
        if (!$this->disponible) {
            $this->disponible = true;
            echo "âœ… Livre '$this->titre' retournÃ© avec succÃ¨s.\n";
        } else {
            echo "âš ï¸ Ce livre n'Ã©tait pas empruntÃ©.\n";
        }
    }

    // Getter : obtenir les informations du livre
    public function getInfo() {
        $statut = $this->disponible ? "disponible" : "empruntÃ©";
        return "\"$this->titre\" par $this->auteur ($this->annee) - $statut";
    }

    // Getter : vÃ©rifier la disponibilitÃ©
    public function estDisponible() {
        return $this->disponible;
    }
}


// ==================== UTILISATION ====================

echo "=== SYSTÃˆME DE BIBLIOTHÃˆQUE ===\n\n";

// CrÃ©er plusieurs livres
$livre1 = new Livre("1984", "George Orwell", 1949);
$livre2 = new Livre("Le Petit Prince", "Antoine de Saint-ExupÃ©ry", 1943);
$livre3 = new Livre("Harry Potter", "J.K. Rowling", 1997);

// Afficher les informations
echo $livre1->getInfo() . "\n";
echo $livre2->getInfo() . "\n";
echo $livre3->getInfo() . "\n";
echo "\n";

// Emprunter des livres
$livre1->emprunter();  // âœ… SuccÃ¨s
$livre1->emprunter();  // âŒ DÃ©jÃ  empruntÃ©
echo "\n";

// Afficher l'Ã©tat aprÃ¨s emprunt
echo $livre1->getInfo() . "\n\n";

// Retourner le livre
$livre1->retourner();  // âœ… Retour rÃ©ussi
$livre1->retourner();  // âš ï¸ N'Ã©tait pas empruntÃ©
echo "\n";

// VÃ©rifier la disponibilitÃ©
if ($livre2->estDisponible()) {
    echo "Le livre 2 est disponible !\n";
    $livre2->emprunter();
}
?>


RÃ‰SULTAT D'EXÃ‰CUTION :
----------------------

=== SYSTÃˆME DE BIBLIOTHÃˆQUE ===

"1984" par George Orwell (1949) - disponible
"Le Petit Prince" par Antoine de Saint-ExupÃ©ry (1943) - disponible
"Harry Potter" par J.K. Rowling (1997) - disponible

âœ… Livre '1984' empruntÃ© avec succÃ¨s.
âŒ DÃ©solÃ©, '1984' est dÃ©jÃ  empruntÃ©.

"1984" par George Orwell (1949) - empruntÃ©

âœ… Livre '1984' retournÃ© avec succÃ¨s.
âš ï¸ Ce livre n'Ã©tait pas empruntÃ©.

Le livre 2 est disponible !
âœ… Livre 'Le Petit Prince' empruntÃ© avec succÃ¨s.


CE QUI EST BIEN DANS CET EXEMPLE :
-----------------------------------
âœ… Encapsulation : Les propriÃ©tÃ©s sont private (on ne peut pas tricher)
âœ… Constructeur : Initialisation simple et claire
âœ… Validation : Impossible d'emprunter un livre dÃ©jÃ  empruntÃ©
âœ… Getters : AccÃ¨s contrÃ´lÃ© aux informations
âœ… $this : UtilisÃ© correctement pour accÃ©der aux propriÃ©tÃ©s
âœ… Logique mÃ©tier : Le code reflÃ¨te la rÃ©alitÃ© (bibliothÃ¨que)


SANS POO, CE CODE SERAIT BEAUCOUP PLUS COMPLIQUÃ‰ :
---------------------------------------------------
Avec POO, tout est organisÃ© et logique. Sans POO, vous auriez besoin de
multiples variables et fonctions Ã©parpillÃ©es, difficiles Ã  maintenir.


================================================================================
K. POINTS CLÃ‰S Ã€ RETENIR
================================================================================

RÃ‰CAPITULATIF DES CONCEPTS ESSENTIELS :
----------------------------------------

1. POO = Programmation OrientÃ©e Objet
   â†’ Organiser le code autour d'objets reprÃ©sentant des Ã©lÃ©ments rÃ©els

2. CLASSE = Plan, modÃ¨le, blueprint
   â†’ DÃ©finit la structure (propriÃ©tÃ©s et mÃ©thodes)

3. OBJET = Instance de classe
   â†’ CrÃ©Ã© avec "new", existe en mÃ©moire

4. PROPRIÃ‰TÃ‰ = Variable dans une classe
   â†’ Stocke les donnÃ©es de l'objet

5. MÃ‰THODE = Fonction dans une classe
   â†’ DÃ©finit les actions de l'objet

6. public = Accessible PARTOUT
   â†’ De l'intÃ©rieur, de l'extÃ©rieur, des enfants
   â†’ UtilisÃ© pour l'interface publique

7. private = Accessible UNIQUEMENT dans la classe
   â†’ Pas accessible de l'extÃ©rieur ni des enfants
   â†’ UtilisÃ© pour protÃ©ger les donnÃ©es sensibles

8. protected = Accessible dans la classe ET les enfants
   â†’ Pas accessible de l'extÃ©rieur
   â†’ UtilisÃ© pour partager avec les classes dÃ©rivÃ©es

9. CONSTRUCTEUR __construct() = Initialisation automatique
   â†’ AppelÃ© automatiquement lors de "new"
   â†’ Permet d'initialiser les propriÃ©tÃ©s en une ligne

10. $this = RÃ©fÃ©rence Ã  l'objet actuel
    â†’ "MOI-MÃŠME", "CET OBJET-CI"
    â†’ UtilisÃ© pour accÃ©der aux propriÃ©tÃ©s/mÃ©thodes internes

11. extends = HÃ©ritage
    â†’ RÃ©utiliser du code d'une classe parent
    â†’ Relation "EST UN" (Un Chien EST UN Animal)

12. ENCAPSULATION = ProtÃ©ger les donnÃ©es
    â†’ PropriÃ©tÃ©s private + mÃ©thodes public
    â†’ Getters/Setters pour contrÃ´ler l'accÃ¨s

13. FLÃˆCHE (->) = AccÃ©der aux membres d'un objet
    â†’ $objet->propriete
    â†’ $objet->methode()

14. CONVENTION : Classes en PascalCase
    â†’ class Utilisateur, class CompteBancaire, class VoitureElectrique

15. PRINCIPE DU MOINDRE PRIVILÃˆGE
    â†’ Commencer par private, rendre public si nÃ©cessaire
    â†’ ProtÃ©ger par dÃ©faut, exposer uniquement ce qui est utile

16. MOT-CLÃ‰ "class" = DÃ©finir une classe
    â†’ Les classes sont dÃ©finies avec le mot-clÃ© rÃ©servÃ© "class"
    â†’ Indique au moteur PHP que vous crÃ©ez une nouvelle classe

17. TRANSFORMATION TERMINOLOGIQUE
    â†’ Variables deviennent PROPRIÃ‰TÃ‰S dans une classe
    â†’ Fonctions deviennent MÃ‰THODES dans une classe

18. OPÃ‰RATEUR -> (Object Operator)
    â†’ UtilisÃ© pour accÃ©der aux membres (propriÃ©tÃ©s et mÃ©thodes) d'un objet
    â†’ Syntaxe : $objet->membre

19. MOT-CLÃ‰ "new" = Instancier un objet
    â†’ CrÃ©e une nouvelle instance (objet) Ã  partir d'une classe
    â†’ Syntaxe : $objet = new NomClasse();


TABLEAU RÃ‰CAPITULATIF DES MODIFICATEURS :
------------------------------------------

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ Modificateur â”‚ Dans       â”‚ Classe      â”‚ ExtÃ©rieur   â”‚ Utilisation    â”‚
â”‚              â”‚ la classe  â”‚ enfant      â”‚             â”‚ typique        â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ public       â”‚ âœ… Oui     â”‚ âœ… Oui      â”‚ âœ… Oui      â”‚ Interface      â”‚
â”‚              â”‚            â”‚             â”‚             â”‚ publique       â”‚
â”‚              â”‚            â”‚             â”‚             â”‚                â”‚
â”‚ protected    â”‚ âœ… Oui     â”‚ âœ… Oui      â”‚ âŒ Non      â”‚ Partage avec   â”‚
â”‚              â”‚            â”‚             â”‚             â”‚ les enfants    â”‚
â”‚              â”‚            â”‚             â”‚             â”‚                â”‚
â”‚ private      â”‚ âœ… Oui     â”‚ âŒ Non      â”‚ âŒ Non      â”‚ Protection     â”‚
â”‚              â”‚            â”‚             â”‚             â”‚ totale         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜


SYNTAXE ESSENTIELLE :
---------------------

// DÃ©finir une classe
class NomClasse {
    private $propriete;

    public function __construct($valeur) {
        $this->propriete = $valeur;
    }

    public function methode() {
        return $this->propriete;
    }
}

// CrÃ©er un objet
$objet = new NomClasse("valeur");

// Utiliser l'objet
$objet->methode();


ERREURS Ã€ Ã‰VITER :
------------------
âŒ Oublier "new" pour crÃ©er un objet
âŒ Oublier la flÃ¨che -> pour accÃ©der aux membres
âŒ Oublier $this-> pour accÃ©der aux propriÃ©tÃ©s dans les mÃ©thodes
âŒ Rendre tout public (manque de protection)
âŒ Confondre propriÃ©tÃ© et variable locale


BONNES PRATIQUES :
------------------
âœ… Toujours utiliser un constructeur pour initialiser
âœ… Commencer par "private" et rendre "public" si nÃ©cessaire
âœ… Utiliser des noms de classe en PascalCase
âœ… CrÃ©er des getters/setters pour les propriÃ©tÃ©s privÃ©es
âœ… Valider les donnÃ©es dans les setters et le constructeur
âœ… Utiliser l'hÃ©ritage pour les relations "EST UN"
âœ… Commenter votre code pour expliquer la logique mÃ©tier


POUR ALLER PLUS LOIN :
-----------------------
Maintenant que vous maÃ®trisez les bases de la POO, vous pouvez explorer :
â€¢ Classes abstraites (classes qui ne peuvent pas Ãªtre instanciÃ©es)
â€¢ Interfaces (contrats que les classes doivent respecter)
â€¢ Traits (rÃ©utilisation de code sans hÃ©ritage)
â€¢ MÃ©thodes et propriÃ©tÃ©s statiques
â€¢ Namespaces (organisation du code en espaces de noms)
â€¢ Autoloading (chargement automatique des classes)


================================================================================
                        Fichier 9/9 - Guide PHP Complet
================================================================================
